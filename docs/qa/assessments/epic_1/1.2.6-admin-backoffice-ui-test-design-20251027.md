# Test Design: Story 1.2.6 - Backoffice UI for Tenant, Neighborhood, and Lot Management

**Date:** October 27, 2025  
**Test Architect:** Quinn (QA)  
**Story:** 1.2.6 - Backoffice UI for Tenant, Neighborhood, and Lot Management  
**Backend Dependency:** Story 1.2.5 (COMPLETED ✅)

---

## Test Strategy Overview

**Testing Approach:** Risk-based, multi-layer testing strategy
- **Unit Tests:** Form validation, component logic, utility functions
- **Integration Tests:** Server action interactions, data flow, error handling
- **E2E Tests:** Critical user flows, RBAC enforcement, mobile responsiveness
- **Accessibility Tests:** WCAG AA compliance, keyboard navigation, screen reader support
- **Performance Tests:** Load times, cascading select delays, DataTable rendering

**Test Coverage Goals:**
- Critical flows: 100% coverage
- Happy path: 95% coverage
- Error scenarios: 90% coverage
- Edge cases: 80% coverage

---

## Test Execution Matrix

### Layer 1: Unit Tests

**Location:** `apps/web/src/app/(admin)/**/__tests__/`

#### 1.1 Form Validation Tests

**File:** `apps/web/src/app/(admin)/tenants/__tests__/create-tenant-form.test.tsx`

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CreateTenantForm } from '../create-tenant-form';
import { TenantInsertSchema } from '@/lib/schemas/tenant';

describe('CreateTenantForm', () => {
  test('renders form with name and slug fields', () => {
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    expect(screen.getByLabelText(/tenant name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/slug/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /create tenant/i })).toBeInTheDocument();
  });

  test('validates required name field', async () => {
    const user = userEvent.setup();
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    // Submit empty form
    await user.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify error message
    await waitFor(() => {
      expect(screen.getByText(/name is required/i)).toBeInTheDocument();
    });
  });

  test('validates name max length (100 chars)', async () => {
    const user = userEvent.setup();
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    const nameInput = screen.getByLabelText(/tenant name/i);
    
    // Enter 101 characters
    await user.type(nameInput, 'a'.repeat(101));
    await user.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify error
    await waitFor(() => {
      expect(screen.getByText(/must be 100 characters or less/i)).toBeInTheDocument();
    });
  });

  test('validates slug format (lowercase, numbers, hyphens only)', async () => {
    const user = userEvent.setup();
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    const slugInput = screen.getByLabelText(/slug/i);
    
    // Enter invalid slug
    await user.type(slugInput, 'Invalid_Slug!');
    await user.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify error
    await waitFor(() => {
      expect(screen.getByText(/lowercase letters, numbers, and hyphens/i)).toBeInTheDocument();
    });
  });

  test('allows valid slug format', async () => {
    const user = userEvent.setup();
    const onSuccess = jest.fn();
    
    // Mock server action
    jest.mock('@/app/actions/admin', () => ({
      createTenantAction: jest.fn().mockResolvedValue({
        success: true,
        data: { id: '1', name: 'Test', slug: 'test' }
      })
    }));
    
    render(<CreateTenantForm onSuccess={onSuccess} />);
    
    const nameInput = screen.getByLabelText(/tenant name/i);
    const slugInput = screen.getByLabelText(/slug/i);
    
    // Enter valid data
    await userEvent.type(nameInput, 'Test Community');
    await userEvent.type(slugInput, 'test-community');
    
    // Submit
    await userEvent.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify success callback
    await waitFor(() => {
      expect(onSuccess).toHaveBeenCalled();
    });
  });

  test('disables submit button during submission', async () => {
    const user = userEvent.setup();
    
    // Mock slow server action
    jest.mock('@/app/actions/admin', () => ({
      createTenantAction: jest.fn(() => new Promise(resolve => 
        setTimeout(() => resolve({ success: true }), 1000)
      ))
    }));
    
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    const nameInput = screen.getByLabelText(/tenant name/i);
    const submitButton = screen.getByRole('button', { name: /create tenant/i });
    
    // Fill and submit
    await user.type(nameInput, 'Test');
    await user.click(submitButton);
    
    // Verify button disabled
    expect(submitButton).toBeDisabled();
    
    // Verify loading text
    expect(screen.getByText(/creating/i)).toBeInTheDocument();
  });

  test('preserves form input on server error', async () => {
    const user = userEvent.setup();
    
    // Mock failed server action
    jest.mock('@/app/actions/admin', () => ({
      createTenantAction: jest.fn().mockResolvedValue({
        success: false,
        error: 'Server error'
      })
    }));
    
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    const nameInput = screen.getByLabelText(/tenant name/i) as HTMLInputElement;
    
    // Fill and submit
    await user.type(nameInput, 'Test Community');
    await user.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify input preserved
    await waitFor(() => {
      expect(nameInput.value).toBe('Test Community');
    });
  });

  test('resets form on successful submission', async () => {
    const user = userEvent.setup();
    
    // Mock successful server action
    jest.mock('@/app/actions/admin', () => ({
      createTenantAction: jest.fn().mockResolvedValue({
        success: true,
        data: { id: '1', name: 'Test', slug: 'test' }
      })
    }));
    
    render(<CreateTenantForm onSuccess={jest.fn()} />);
    
    const nameInput = screen.getByLabelText(/tenant name/i) as HTMLInputElement;
    
    // Fill and submit
    await user.type(nameInput, 'Test Community');
    await user.click(screen.getByRole('button', { name: /create tenant/i }));
    
    // Verify form reset
    await waitFor(() => {
      expect(nameInput.value).toBe('');
    });
  });
});
```

#### 1.2 Cascading Select Component Tests

**File:** `apps/web/src/components/admin/__tests__/cascading-select.test.tsx`

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CascadingSelect } from '../cascading-select';

describe('CascadingSelect', () => {
  const mockTenants = [
    { id: 'tenant-1', name: 'Community A' },
    { id: 'tenant-2', name: 'Community B' },
  ];

  const mockNeighborhoods = [
    { id: 'neigh-1', name: 'Neighborhood 1' },
    { id: 'neigh-2', name: 'Neighborhood 2' },
  ];

  test('renders tenant select and disabled neighborhood select', () => {
    render(
      <CascadingSelect 
        onNeighborhoodSelect={jest.fn()}
      />
    );
    
    const selects = screen.getAllByRole('combobox');
    expect(selects).toHaveLength(2);
    expect(selects[1]).toBeDisabled(); // Neighborhood select disabled
  });

  test('enables neighborhood select after tenant selection', async () => {
    const user = userEvent.setup();
    
    // Mock tenant fetch
    jest.mock('@/app/actions/admin', () => ({
      listTenantsAction: jest.fn().mockResolvedValue({
        success: true,
        data: mockTenants
      })
    }));
    
    render(
      <CascadingSelect 
        onNeighborhoodSelect={jest.fn()}
      />
    );
    
    const tenantSelect = screen.getAllByRole('combobox')[0];
    
    // Open and select tenant
    await user.click(tenantSelect);
    await user.click(screen.getByText('Community A'));
    
    // Verify neighborhood select enabled
    const neighborhoodSelect = screen.getAllByRole('combobox')[1];
    await waitFor(() => {
      expect(neighborhoodSelect).not.toBeDisabled();
    });
  });

  test('shows loading state while fetching neighborhoods', async () => {
    const user = userEvent.setup();
    
    // Mock slow neighborhood fetch
    jest.mock('@/app/actions/admin', () => ({
      listNeighborhoodsByTenantAction: jest.fn(() => 
        new Promise(resolve => 
          setTimeout(() => resolve({ success: true, data: mockNeighborhoods }), 500)
        )
      )
    }));
    
    render(
      <CascadingSelect 
        onNeighborhoodSelect={jest.fn()}
      />
    );
    
    const tenantSelect = screen.getAllByRole('combobox')[0];
    
    // Select tenant
    await user.click(tenantSelect);
    await user.click(screen.getByText('Community A'));
    
    // Verify loading spinner
    expect(screen.getByText(/loading neighborhoods/i)).toBeInTheDocument();
    
    // Wait for neighborhoods to load
    await waitFor(() => {
      expect(screen.queryByText(/loading neighborhoods/i)).not.toBeInTheDocument();
    });
  });

  test('shows error message on neighborhood fetch failure', async () => {
    const user = userEvent.setup();
    
    // Mock failed neighborhood fetch
    jest.mock('@/app/actions/admin', () => ({
      listNeighborhoodsByTenantAction: jest.fn().mockResolvedValue({
        success: false,
        error: 'Failed to load neighborhoods'
      })
    }));
    
    render(
      <CascadingSelect 
        onNeighborhoodSelect={jest.fn()}
      />
    );
    
    const tenantSelect = screen.getAllByRole('combobox')[0];
    
    // Select tenant
    await user.click(tenantSelect);
    await user.click(screen.getByText('Community A'));
    
    // Verify error message
    await waitFor(() => {
      expect(screen.getByText(/failed to load neighborhoods/i)).toBeInTheDocument();
    });
  });

  test('provides retry button on error', async () => {
    const user = userEvent.setup();
    
    // Mock failed neighborhood fetch
    jest.mock('@/app/actions/admin', () => ({
      listNeighborhoodsByTenantAction: jest.fn().mockResolvedValue({
        success: false,
        error: 'Failed to load neighborhoods'
      })
    }));
    
    render(
      <CascadingSelect 
        onNeighborhoodSelect={jest.fn()}
      />
    );
    
    const tenantSelect = screen.getAllByRole('combobox')[0];
    
    // Select tenant
    await user.click(tenantSelect);
    await user.click(screen.getByText('Community A'));
    
    // Verify retry button
    await waitFor(() => {
      expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument();
    });
  });

  test('calls onNeighborhoodSelect callback when neighborhood selected', async () => {
    const user = userEvent.setup();
    const onNeighborhoodSelect = jest.fn();
    
    // Mock neighborhood fetch
    jest.mock('@/app/actions/admin', () => ({
      listNeighborhoodsByTenantAction: jest.fn().mockResolvedValue({
        success: true,
        data: mockNeighborhoods
      })
    }));
    
    render(
      <CascadingSelect 
        onNeighborhoodSelect={onNeighborhoodSelect}
      />
    );
    
    const tenantSelect = screen.getAllByRole('combobox')[0];
    
    // Select tenant
    await user.click(tenantSelect);
    await user.click(screen.getByText('Community A'));
    
    // Wait for neighborhoods to load
    await waitFor(() => {
      expect(screen.getByText('Neighborhood 1')).toBeInTheDocument();
    });
    
    // Select neighborhood
    const neighborhoodSelect = screen.getAllByRole('combobox')[1];
    await user.click(neighborhoodSelect);
    await user.click(screen.getByText('Neighborhood 1'));
    
    // Verify callback
    expect(onNeighborhoodSelect).toHaveBeenCalledWith('neigh-1');
  });
});
```

#### 1.3 RBAC Guard Component Tests

**File:** `apps/web/src/lib/components/__tests__/admin-rbac-guard.test.tsx`

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import { AdminRBACGuard } from '../admin-rbac-guard';
import { useRouter } from 'next/navigation';

jest.mock('next/navigation');

describe('AdminRBACGuard', () => {
  const mockPush = jest.fn();

  beforeEach(() => {
    (useRouter as jest.Mock).mockReturnValue({
      push: mockPush,
    });
  });

  test('shows loading state initially', () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn(() => new Promise(() => {})) // Never resolves
    }));
    
    render(
      <AdminRBACGuard>
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Verify loading skeleton visible
    expect(screen.getByTestId('loading-skeleton')).toBeInTheDocument();
    expect(screen.queryByText('Protected Content')).not.toBeInTheDocument();
  });

  test('renders children for authorized admin user', async () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn().mockResolvedValue({
        id: 'user-1',
        role: 'admin'
      })
    }));
    
    render(
      <AdminRBACGuard>
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Wait for authorization check
    await waitFor(() => {
      expect(screen.getByText('Protected Content')).toBeInTheDocument();
    });
  });

  test('renders children for authorized super_admin user', async () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn().mockResolvedValue({
        id: 'user-1',
        role: 'super_admin'
      })
    }));
    
    render(
      <AdminRBACGuard>
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Wait for authorization check
    await waitFor(() => {
      expect(screen.getByText('Protected Content')).toBeInTheDocument();
    });
  });

  test('redirects non-admin user to home', async () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn().mockResolvedValue({
        id: 'user-1',
        role: 'user'
      })
    }));
    
    render(
      <AdminRBACGuard>
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Wait for redirect
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/');
    });
    
    // Verify access denied message
    expect(screen.getByText(/access denied/i)).toBeInTheDocument();
  });

  test('redirects to login on auth error', async () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn().mockRejectedValue(new Error('Auth failed'))
    }));
    
    render(
      <AdminRBACGuard>
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Wait for redirect
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/login');
    });
  });

  test('respects requiredRole prop for super_admin only', async () => {
    jest.mock('@/app/actions/user', () => ({
      getCurrentUser: jest.fn().mockResolvedValue({
        id: 'user-1',
        role: 'admin' // Not super_admin
      })
    }));
    
    render(
      <AdminRBACGuard requiredRole="super_admin">
        <div>Protected Content</div>
      </AdminRBACGuard>
    );
    
    // Wait for redirect
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith('/');
    });
  });
});
```

---

### Layer 2: Integration Tests

**Location:** `apps/web/app/actions/__tests__/`

#### 2.1 Server Action Integration Tests

**File:** `apps/web/app/actions/__tests__/admin.integration.test.ts`

```typescript
import { createTenantAction, createNeighborhoodAction, createLotAction } from '../admin';
import { TenantInsertSchema, NeighborhoodInsertSchema, LotInsertSchema } from '@/lib/schemas';

describe('Admin Server Actions - Integration', () => {
  describe('createTenantAction', () => {
    test('creates tenant with valid input', async () => {
      const input = {
        name: 'Test Community',
        slug: 'test-community'
      };
      
      const result = await createTenantAction(input);
      
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('id');
      expect(result.data.name).toBe('Test Community');
      expect(result.data.slug).toBe('test-community');
    });

    test('returns validation error for invalid input', async () => {
      const input = {
        name: '', // Invalid: empty
        slug: 'test'
      };
      
      const result = await createTenantAction(input);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Name is required');
    });

    test('returns error for duplicate tenant name', async () => {
      // Create first tenant
      await createTenantAction({
        name: 'Duplicate Test',
        slug: 'duplicate-test'
      });
      
      // Try to create duplicate
      const result = await createTenantAction({
        name: 'Duplicate Test',
        slug: 'duplicate-test-2'
      });
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('already exists');
    });
  });

  describe('createNeighborhoodAction', () => {
    let tenantId: string;

    beforeAll(async () => {
      // Create test tenant
      const tenantResult = await createTenantAction({
        name: 'Test Tenant',
        slug: 'test-tenant'
      });
      tenantId = tenantResult.data.id;
    });

    test('creates neighborhood with valid input', async () => {
      const input = {
        tenant_id: tenantId,
        name: 'Test Neighborhood',
        description: 'A test neighborhood'
      };
      
      const result = await createNeighborhoodAction(input);
      
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('id');
      expect(result.data.name).toBe('Test Neighborhood');
      expect(result.data.tenant_id).toBe(tenantId);
    });

    test('returns error for invalid tenant_id', async () => {
      const input = {
        tenant_id: 'invalid-uuid',
        name: 'Test Neighborhood'
      };
      
      const result = await createNeighborhoodAction(input);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid tenant');
    });

    test('enforces RBAC - non-admin cannot create for other tenant', async () => {
      // This test requires auth context setup
      // Mock non-admin user
      const input = {
        tenant_id: 'other-tenant-id',
        name: 'Unauthorized Neighborhood'
      };
      
      const result = await createNeighborhoodAction(input);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Unauthorized');
    });
  });

  describe('createLotAction', () => {
    let neighborhoodId: string;

    beforeAll(async () => {
      // Create test tenant and neighborhood
      const tenantResult = await createTenantAction({
        name: 'Lot Test Tenant',
        slug: 'lot-test-tenant'
      });
      
      const neighResult = await createNeighborhoodAction({
        tenant_id: tenantResult.data.id,
        name: 'Lot Test Neighborhood'
      });
      
      neighborhoodId = neighResult.data.id;
    });

    test('creates lot with valid input', async () => {
      const input = {
        neighborhood_id: neighborhoodId,
        lot_number: 'LOT-001',
        status: 'available' as const
      };
      
      const result = await createLotAction(input);
      
      expect(result.success).toBe(true);
      expect(result.data).toHaveProperty('id');
      expect(result.data.lot_number).toBe('LOT-001');
      expect(result.data.status).toBe('available');
    });

    test('prevents duplicate lot_number in same neighborhood', async () => {
      // Create first lot
      await createLotAction({
        neighborhood_id: neighborhoodId,
        lot_number: 'LOT-DUP',
        status: 'available'
      });
      
      // Try to create duplicate
      const result = await createLotAction({
        neighborhood_id: neighborhoodId,
        lot_number: 'LOT-DUP',
        status: 'available'
      });
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('already exists');
    });

    test('allows same lot_number in different neighborhoods', async () => {
      // Create second neighborhood
      const tenantResult = await createTenantAction({
        name: 'Multi Neigh Tenant',
        slug: 'multi-neigh-tenant'
      });
      
      const neigh2Result = await createNeighborhoodAction({
        tenant_id: tenantResult.data.id,
        name: 'Second Neighborhood'
      });
      
      // Create lot with same number in different neighborhood
      const result = await createLotAction({
        neighborhood_id: neigh2Result.data.id,
        lot_number: 'LOT-001', // Same as first neighborhood
        status: 'available'
      });
      
      expect(result.success).toBe(true);
    });

    test('returns error for invalid neighborhood_id', async () => {
      const input = {
        neighborhood_id: 'invalid-uuid',
        lot_number: 'LOT-TEST',
        status: 'available' as const
      };
      
      const result = await createLotAction(input);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid neighborhood');
    });
  });

  describe('RLS Isolation Tests', () => {
    test('Tenant A admin cannot access Tenant B neighborhoods', async () => {
      // Create two tenants
      const tenant1 = await createTenantAction({
        name: 'Tenant A',
        slug: 'tenant-a'
      });
      
      const tenant2 = await createTenantAction({
        name: 'Tenant B',
        slug: 'tenant-b'
      });
      
      // Create neighborhood in Tenant B
      const neigh = await createNeighborhoodAction({
        tenant_id: tenant2.data.id,
        name: 'Tenant B Neighborhood'
      });
      
      // Switch to Tenant A context and try to access Tenant B neighborhood
      // This requires auth context switching - implementation depends on auth setup
      
      // Expected: Access denied or empty result
    });
  });
});
```

---

### Layer 3: E2E Tests

**Location:** `apps/web/e2e/`

#### 3.1 Critical User Flows

**File:** `apps/web/e2e/admin-ui-critical-flows.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Admin UI - Critical Flows', () => {
  test.beforeEach(async ({ page }) => {
    // Login as admin
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');
    
    // Wait for redirect to dashboard
    await page.waitForURL('/dashboard');
  });

  test('Complete Flow: Create Tenant → Neighborhood → Lot', async ({ page }) => {
    // Navigate to tenants page
    await page.goto('/admin/tenants');
    await expect(page.locator('text=Tenants')).toBeVisible();

    // Create tenant
    const tenantName = `Test Tenant ${Date.now()}`;
    await page.fill('input[name="name"]', tenantName);
    await page.click('button:has-text("Create Tenant")');

    // Verify success toast
    await expect(page.locator('text=Tenant created successfully')).toBeVisible();

    // Verify tenant in table
    await expect(page.locator(`text=${tenantName}`)).toBeVisible();

    // Navigate to neighborhoods
    await page.goto('/admin/neighborhoods');

    // Select tenant
    const tenantSelect = page.locator('[role="combobox"]').first();
    await tenantSelect.click();
    await page.locator(`text=${tenantName}`).click();

    // Wait for neighborhoods to load
    await page.waitForTimeout(500);

    // Create neighborhood
    const neighborhoodName = `Test Neighborhood ${Date.now()}`;
    await page.fill('input[name="name"]', neighborhoodName);
    await page.click('button:has-text("Create Neighborhood")');

    // Verify success
    await expect(page.locator('text=Neighborhood created successfully')).toBeVisible();

    // Navigate to lots
    await page.goto('/admin/lots');

    // Select tenant
    const tenantSelectLots = page.locator('[role="combobox"]').first();
    await tenantSelectLots.click();
    await page.locator(`text=${tenantName}`).click();

    // Wait for neighborhoods to load
    await page.waitForTimeout(500);

    // Select neighborhood
    const neighborhoodSelectLots = page.locator('[role="combobox"]').nth(1);
    await neighborhoodSelectLots.click();
    await page.locator(`text=${neighborhoodName}`).click();

    // Create lot
    const lotNumber = `LOT-${Date.now()}`;
    await page.fill('input[name="lot_number"]', lotNumber);
    await page.click('button:has-text("Create Lot")');

    // Verify success
    await expect(page.locator('text=Lot created successfully')).toBeVisible();

    // Verify lot in table
    await expect(page.locator(`text=${lotNumber}`)).toBeVisible();
  });

  test('RBAC: Non-admin user redirected from /admin/tenants', async ({ page }) => {
    // Logout admin
    await page.click('button:has-text("Logout")');

    // Login as non-admin
    await page.goto('/login');
    await page.fill('input[name="email"]', 'user@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');

    // Try to access admin page
    await page.goto('/admin/tenants');

    // Verify redirect to home
    await expect(page).toHaveURL('/');
  });

  test('Form Validation: Empty name field shows error', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Submit empty form
    await page.click('button:has-text("Create Tenant")');

    // Verify validation error
    await expect(page.locator('text=Name is required')).toBeVisible();
  });

  test('Delete Confirmation: Cancel button closes dialog', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Find first delete button
    const deleteButton = page.locator('button:has-text("Delete")').first();
    await deleteButton.click();

    // Verify dialog appears
    await expect(page.locator('[role="dialog"]')).toBeVisible();

    // Click cancel
    await page.click('button:has-text("Cancel")');

    // Verify dialog closes
    await expect(page.locator('[role="dialog"]')).not.toBeVisible();
  });

  test('Cascading Select: Neighborhood select disabled until tenant selected', async ({ page }) => {
    await page.goto('/admin/lots');

    // Verify neighborhood select is disabled
    const neighborhoodSelect = page.locator('[role="combobox"]').nth(1);
    await expect(neighborhoodSelect).toBeDisabled();

    // Select tenant
    const tenantSelect = page.locator('[role="combobox"]').first();
    await tenantSelect.click();
    await page.locator('text=Test Community').click();

    // Wait for neighborhoods to load
    await page.waitForTimeout(500);

    // Verify neighborhood select is enabled
    await expect(neighborhoodSelect).not.toBeDisabled();
  });
});
```

#### 3.2 Mobile Responsiveness Tests

**File:** `apps/web/e2e/admin-ui-mobile.spec.ts`

```typescript
import { test, expect, devices } from '@playwright/test';

test.describe('Admin UI - Mobile Responsiveness', () => {
  test.use({ ...devices['iPhone 12'] });

  test.beforeEach(async ({ page }) => {
    // Login as admin
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');
    
    await page.waitForURL('/dashboard');
  });

  test('Tenants page layout on mobile', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Verify no horizontal scroll
    const bodyWidth = await page.evaluate(() => document.body.scrollWidth);
    const viewportWidth = await page.evaluate(() => window.innerWidth);
    expect(bodyWidth).toBeLessThanOrEqual(viewportWidth);

    // Verify touch targets are 44px minimum
    const buttons = await page.locator('button').all();
    for (const button of buttons) {
      const box = await button.boundingBox();
      expect(box?.height).toBeGreaterThanOrEqual(44);
      expect(box?.width).toBeGreaterThanOrEqual(44);
    }
  });

  test('DataTable scrolls horizontally on mobile', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Verify table is scrollable
    const tableContainer = page.locator('.overflow-x-auto');
    const isScrollable = await tableContainer.evaluate(
      el => el.scrollWidth > el.clientWidth
    );
    expect(isScrollable).toBe(true);
  });

  test('Forms stack vertically on mobile', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Check form grid layout
    const formGrid = page.locator('form .grid');
    const gridCols = await formGrid.evaluate(
      el => window.getComputedStyle(el).gridTemplateColumns
    );
    
    // Should be single column on mobile
    expect(gridCols).toContain('1fr');
  });

  test('Cascading selects work on mobile', async ({ page }) => {
    await page.goto('/admin/lots');

    // Select tenant
    const tenantSelect = page.locator('[role="combobox"]').first();
    await tenantSelect.click();
    await page.locator('text=Test Community').click();

    // Wait for neighborhoods
    await page.waitForTimeout(500);

    // Select neighborhood
    const neighborhoodSelect = page.locator('[role="combobox"]').nth(1);
    await neighborhoodSelect.click();
    await page.locator('text=Test Neighborhood').click();

    // Verify lots list appears
    await expect(page.locator('text=Lot Number')).toBeVisible();
  });
});
```

#### 3.3 Accessibility Tests

**File:** `apps/web/e2e/admin-ui-accessibility.spec.ts`

```typescript
import { test, expect } from '@playwright/test';
import { injectAxe, checkA11y } from 'axe-playwright';

test.describe('Admin UI - Accessibility', () => {
  test.beforeEach(async ({ page }) => {
    // Login as admin
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');
    
    await page.waitForURL('/dashboard');
  });

  test('Tenants page meets WCAG AA standards', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Inject axe
    await injectAxe(page);
    
    // Check accessibility
    await checkA11y(page, null, {
      detailedReport: true,
    });
  });

  test('Neighborhoods page meets WCAG AA standards', async ({ page }) => {
    await page.goto('/admin/neighborhoods');
    
    await injectAxe(page);
    await checkA11y(page, null, {
      detailedReport: true,
    });
  });

  test('Lots page meets WCAG AA standards', async ({ page }) => {
    await page.goto('/admin/lots');
    
    await injectAxe(page);
    await checkA11y(page, null, {
      detailedReport: true,
    });
  });

  test('Cascading select is keyboard navigable', async ({ page }) => {
    await page.goto('/admin/lots');
    
    // Tab to tenant select
    await page.keyboard.press('Tab');
    
    // Open with Enter
    await page.keyboard.press('Enter');
    
    // Verify dropdown opens
    await expect(page.locator('[role="option"]').first()).toBeVisible();
    
    // Navigate with arrow keys
    await page.keyboard.press('ArrowDown');
    
    // Select with Enter
    await page.keyboard.press('Enter');
    
    // Verify selection
    const tenantSelect = page.locator('[role="combobox"]').first();
    await expect(tenantSelect).toHaveAttribute('aria-expanded', 'false');
  });

  test('Delete dialog traps focus', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Open delete dialog
    const deleteButton = page.locator('button:has-text("Delete")').first();
    await deleteButton.click();
    
    // Verify dialog is visible
    await expect(page.locator('[role="dialog"]')).toBeVisible();
    
    // Tab through dialog and verify focus stays within
    const focusedElements = [];
    for (let i = 0; i < 10; i++) {
      const focused = await page.evaluate(() => document.activeElement?.getAttribute('role'));
      focusedElements.push(focused);
      await page.keyboard.press('Tab');
    }
    
    // Verify focus stayed within dialog
    const hasDialogFocus = focusedElements.some(el => 
      el === 'button' || el === 'dialog'
    );
    expect(hasDialogFocus).toBe(true);
  });

  test('Form labels are properly associated', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Check label associations
    const nameLabel = page.locator('label:has-text("Tenant Name")');
    const nameInput = page.locator('input[name="name"]');
    
    const labelFor = await nameLabel.getAttribute('for');
    const inputId = await nameInput.getAttribute('id');
    
    expect(labelFor).toBe(inputId);
  });
});
```

---

### Layer 4: Performance Tests

**File:** `apps/web/e2e/admin-ui-performance.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Admin UI - Performance', () => {
  test.beforeEach(async ({ page }) => {
    // Login as admin
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');
    
    await page.waitForURL('/dashboard');
  });

  test('Cascading select neighborhood fetch completes within 2 seconds', async ({ page }) => {
    await page.goto('/admin/lots');
    
    const startTime = Date.now();
    
    // Select tenant
    const tenantSelect = page.locator('[role="combobox"]').first();
    await tenantSelect.click();
    await page.locator('text=Test Community').click();
    
    // Wait for neighborhoods to load
    await page.waitForSelector('[role="option"]');
    
    const duration = Date.now() - startTime;
    
    // Should complete within 2 seconds
    expect(duration).toBeLessThan(2000);
  });

  test('DataTable renders with 100+ rows without lag', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Measure rendering time
    const startTime = Date.now();
    
    // Wait for table to render
    await page.waitForSelector('table tbody tr');
    
    const duration = Date.now() - startTime;
    
    // Should render within 1 second
    expect(duration).toBeLessThan(1000);
  });

  test('Form submission completes within 5 seconds', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    const startTime = Date.now();
    
    // Fill and submit form
    await page.fill('input[name="name"]', `Perf Test ${Date.now()}`);
    await page.click('button:has-text("Create Tenant")');
    
    // Wait for success
    await page.waitForSelector('text=Tenant created successfully');
    
    const duration = Date.now() - startTime;
    
    // Should complete within 5 seconds
    expect(duration).toBeLessThan(5000);
  });
});
```

---

## Test Execution Plan

### Phase 1: Unit Tests (Days 1-2)
- Form validation tests
- Cascading select component tests
- RBAC guard component tests
- **Target Coverage:** 95%+

### Phase 2: Integration Tests (Days 2-3)
- Server action integration tests
- RLS isolation tests
- Error handling tests
- **Target Coverage:** 90%+

### Phase 3: E2E Tests (Days 3-4)
- Critical user flows
- RBAC enforcement
- Form validation
- Delete confirmation
- **Target Coverage:** 100% of critical paths

### Phase 4: Mobile & Accessibility (Days 4-5)
- Mobile responsiveness tests
- Keyboard navigation tests
- WCAG AA compliance tests
- Screen reader support tests
- **Target Coverage:** All viewports, WCAG AA

### Phase 5: Performance Tests (Day 5)
- Cascading select performance
- DataTable rendering performance
- Form submission performance
- **Target:** All operations < 2 seconds

---

## Test Data Setup

**Seed Data Required:**
```typescript
// Test admin user
{
  email: 'admin@test.com',
  password: 'password123',
  role: 'admin'
}

// Test regular user
{
  email: 'user@test.com',
  password: 'password123',
  role: 'user'
}

// Test tenants
{
  name: 'Test Community',
  slug: 'test-community'
}

// Test neighborhoods
{
  tenant_id: 'test-community-id',
  name: 'Test Neighborhood',
  description: 'A test neighborhood'
}
```

---

## Test Reporting

**Metrics to Track:**
- Test pass rate (target: 100%)
- Code coverage (target: 95%+)
- Performance metrics (all operations < 2s)
- Accessibility violations (target: 0)
- Flaky test rate (target: < 2%)

**Report Format:**
- Daily test summary
- Coverage report
- Performance baseline
- Accessibility audit results
- Blocking issues

---

## Sign-Off

**Test Design Status:** ✅ READY FOR EXECUTION

**Test Infrastructure Required:**
- Playwright E2E framework
- Jest for unit/integration tests
- axe-core for accessibility testing
- Test database with seed data

**Next Steps:**
1. Set up test infrastructure
2. Execute Phase 1 (Unit Tests)
3. Execute Phase 2 (Integration Tests)
4. Execute Phase 3-5 (E2E, Mobile, Accessibility, Performance)
5. Generate final test report

**Review Date:** October 27, 2025  
**Test Architect:** Quinn (QA)
