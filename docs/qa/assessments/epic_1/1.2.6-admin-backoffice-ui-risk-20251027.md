# Risk Profile: Story 1.2.6 - Backoffice UI for Tenant, Neighborhood, and Lot Management

**Date:** October 27, 2025  
**Reviewer:** Quinn (Test Architect & QA)  
**Story Status:** Ready for Implementation  
**Backend Dependency:** Story 1.2.5 (COMPLETED ✅)

---

## Executive Summary

- **Total Risks Identified:** 9
- **Critical Risks (Score 9):** 0
- **High Risks (Score 6):** 3
- **Medium Risks (Score 4):** 4
- **Low Risks (Score 2-3):** 2
- **Overall Risk Score:** 45/100

**Key Concerns:**
1. Cascading select UX complexity on mobile devices
2. RBAC guard implementation consistency and edge cases
3. Form state management with async server actions
4. Mobile-first responsive design compliance across all viewports
5. E2E test reliability for complex interactive flows

**Positive Factors:**
- Backend (1.2.5) is complete and tested
- Clear design system and component library established
- Acceptance criteria are detailed and specific
- Shadcn/ui components provide accessibility foundation

---

## High Priority Risks

### 1. [UX-001]: Cascading Select Complexity on Mobile

**Score: 6 (High)**  
**Category:** User Experience / Mobile  
**Probability:** Medium (2) - Complex multi-step interaction pattern  
**Impact:** High (3) - Poor UX, user errors, support burden

**Description:**

AC3 requires cascading selects: Tenant → Neighborhood → Lot. On mobile (< 640px), this creates friction:

**Mobile UX Issues:**
1. **Viewport Space**: Three select dropdowns stack vertically, consuming significant screen real estate
2. **Interaction Friction**: User must:
   - Open tenant select
   - Select tenant
   - Wait for neighborhood options to load
   - Open neighborhood select
   - Select neighborhood
   - Wait for lot options to load
   - See lot list
3. **Loading States**: No visual feedback during async fetches between selects
4. **Error Recovery**: If neighborhood fetch fails, user has no clear path to retry
5. **Touch Targets**: Select dropdowns must maintain 44x44px minimum, but label + select + loading state may compress spacing

**Affected Components:**
- `apps/web/src/app/(admin)/lots/page.tsx` (cascading selects)
- `apps/web/src/components/admin/cascading-select.tsx` (reusable component)

**Evidence from AC:**
- AC3: "Cascading Select, fetches via 1.2.5 listByTenant (filtered by selected tenant)"
- AC5: "Mobile-first (Tailwind responsive utilities: sm:, md:, lg: breakpoints). Touch targets minimum 44x44px."
- AC6: "Loading States & Error Handling: All async operations show loading spinners"

**Failure Scenarios:**
1. User selects tenant on mobile, neighborhood dropdown appears but is cut off by keyboard
2. Neighborhood fetch takes > 2 seconds, user thinks interaction failed
3. User accidentally closes select while loading, must restart
4. On slow network, cascading requests create waterfall delays (tenant → neighborhood → lots)

**Mitigation:**

**UX Improvements:**

1. **Optimistic Loading & Preloading:**
```typescript
// apps/web/src/components/admin/cascading-select.tsx
export function CascadingSelect({ 
  tenantId, 
  onNeighborhoodSelect 
}: Props) {
  const [selectedTenant, setSelectedTenant] = useState<string | null>(null);
  const [neighborhoods, setNeighborhoods] = useState<Neighborhood[]>([]);
  const [isLoadingNeighborhoods, setIsLoadingNeighborhoods] = useState(false);

  const handleTenantChange = async (tenantId: string) => {
    setSelectedTenant(tenantId);
    setIsLoadingNeighborhoods(true);
    
    try {
      // Fetch neighborhoods for selected tenant
      const result = await listNeighborhoodsByTenantAction(tenantId);
      if (result.success) {
        setNeighborhoods(result.data);
      } else {
        // Show error toast, keep previous state
        toast.error(result.error || 'Failed to load neighborhoods');
      }
    } finally {
      setIsLoadingNeighborhoods(false);
    }
  };

  return (
    <div className="space-y-4">
      {/* Tenant Select */}
      <Select value={selectedTenant} onValueChange={handleTenantChange}>
        <SelectTrigger className="h-11 min-h-[44px]">
          <SelectValue placeholder="Select a tenant" />
        </SelectTrigger>
        <SelectContent>
          {/* Options */}
        </SelectContent>
      </Select>

      {/* Neighborhood Select - Disabled until tenant selected */}
      <div className="relative">
        <Select 
          disabled={!selectedTenant || isLoadingNeighborhoods}
          onValueChange={onNeighborhoodSelect}
        >
          <SelectTrigger className="h-11 min-h-[44px]">
            {isLoadingNeighborhoods ? (
              <span className="flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin" />
                Loading neighborhoods...
              </span>
            ) : (
              <SelectValue placeholder="Select a neighborhood" />
            )}
          </SelectTrigger>
          <SelectContent>
            {neighborhoods.map(n => (
              <SelectItem key={n.id} value={n.id}>
                {n.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}
```

2. **Mobile-Optimized Layout:**
```typescript
// apps/web/src/app/(admin)/lots/page.tsx
export default function LotsPage() {
  return (
    <div className="space-y-6 p-4 sm:p-6">
      {/* Cascading selects in card */}
      <Card className="p-4 sm:p-6">
        <h2 className="mb-4 text-lg font-semibold">Filter Lots</h2>
        <CascadingSelect 
          onNeighborhoodSelect={handleNeighborhoodSelect}
        />
      </Card>

      {/* Lots list below - scrollable on mobile */}
      <Card className="overflow-hidden">
        <div className="overflow-x-auto">
          <DataTable columns={columns} data={lots} />
        </div>
      </Card>
    </div>
  );
}
```

3. **Error Recovery:**
```typescript
// Show retry button if neighborhood fetch fails
{isLoadingNeighborhoods && (
  <div className="flex items-center gap-2 text-sm text-amber-600">
    <AlertCircle className="h-4 w-4" />
    <span>Loading neighborhoods...</span>
  </div>
)}

{neighborhoodError && (
  <div className="flex items-center justify-between gap-2 rounded-md bg-red-50 p-3 text-sm text-red-700">
    <span>{neighborhoodError}</span>
    <Button 
      size="sm" 
      variant="outline"
      onClick={() => handleTenantChange(selectedTenant!)}
    >
      Retry
    </Button>
  </div>
)}
```

**Testing Requirements:**

**Mobile UX Tests (Playwright):**
```typescript
test('Cascading selects on mobile (iPhone 12)', async ({ page }) => {
  await page.setViewportSize({ width: 390, height: 844 });
  
  // Navigate to lots page
  await page.goto('/admin/lots');
  
  // Select tenant
  const tenantSelect = page.locator('[role="combobox"]').first();
  await tenantSelect.click();
  await page.locator('text=Test Community').click();
  
  // Verify neighborhood select is enabled and loading
  const neighborhoodSelect = page.locator('[role="combobox"]').nth(1);
  await expect(neighborhoodSelect).not.toBeDisabled();
  
  // Wait for neighborhoods to load
  await page.waitForTimeout(500);
  
  // Verify loading spinner visible
  await expect(page.locator('text=Loading neighborhoods')).toBeVisible();
  
  // Wait for neighborhoods to appear
  await page.waitForSelector('[role="option"]');
  
  // Select neighborhood
  await neighborhoodSelect.click();
  await page.locator('text=Test Neighborhood').click();
  
  // Verify lots list appears
  await expect(page.locator('text=Lot Number')).toBeVisible();
});

test('Cascading select error recovery on mobile', async ({ page }) => {
  await page.setViewportSize({ width: 390, height: 844 });
  
  // Mock neighborhood fetch to fail
  await page.route('**/api/neighborhoods*', route => 
    route.abort('failed')
  );
  
  // Select tenant
  const tenantSelect = page.locator('[role="combobox"]').first();
  await tenantSelect.click();
  await page.locator('text=Test Community').click();
  
  // Verify error message appears
  await expect(page.locator('text=Failed to load neighborhoods')).toBeVisible();
  
  // Verify retry button is present
  const retryButton = page.locator('button:has-text("Retry")');
  await expect(retryButton).toBeVisible();
  
  // Click retry
  await retryButton.click();
  
  // Verify neighborhoods load successfully
  await page.waitForSelector('[role="option"]');
});
```

**Performance Tests:**
- Measure cascading select interaction time on slow 3G network
- Verify neighborhood fetch completes within 2 seconds
- Ensure no waterfall delays (parallel fetches where possible)

**Residual Risk:** Low - After UX improvements and mobile testing

**Owner:** Frontend dev  
**Timeline:** Task 4 implementation

---

### 2. [SEC-001]: RBAC Guard Implementation & Edge Cases

**Score: 6 (High)**  
**Category:** Security / Access Control  
**Probability:** Medium (2) - Complex auth state management  
**Impact:** High (3) - Unauthorized access, data exposure

**Description:**

AC4 requires RBAC enforcement: "All admin pages enforce role-based access control (admin-only via 1.2 getCurrentUser; redirect non-admins to home or show 403 error)."

**Implementation Risks:**

1. **Race Condition**: User navigates to /admin/tenants before auth check completes
2. **Session Expiry**: User's session expires mid-navigation, guard doesn't catch it
3. **Role Escalation**: User role changes server-side, client-side cache not invalidated
4. **Redirect Loop**: Non-admin redirected to home, which redirects back to admin
5. **Loading State**: No visual feedback while auth is being verified

**Affected Components:**
- `apps/web/src/app/(admin)/layout.tsx` (RBAC guard)
- `apps/web/src/lib/components/admin-rbac-guard.tsx` (reusable guard)

**Evidence from AC:**
- AC4: "RBAC guard component wraps all admin pages"
- AC6: "Loading States & Error Handling: All async operations show loading spinners"

**Failure Scenarios:**

1. **Race Condition:**
```typescript
// BAD: No loading state, guard checks async
export function AdminLayout({ children }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    getCurrentUser().then(setUser); // Async, no loading state
  }, []);
  
  // Children render before user is loaded!
  if (!user) return null; // Too late, page already rendered
  
  if (user.role !== 'admin') {
    return <Redirect to="/" />;
  }
  
  return children;
}
```

2. **Session Expiry Not Caught:**
```typescript
// User's session expires, but guard doesn't re-check
// User can still see cached admin page
```

3. **Redirect Loop:**
```typescript
// /admin/tenants redirects to /
// / has no redirect, but user tries to access /admin again
// Creates poor UX
```

**Mitigation:**

**Proper RBAC Guard Implementation:**

```typescript
// apps/web/src/lib/components/admin-rbac-guard.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { getCurrentUser } from '@/app/actions/user';
import { Skeleton } from '@/components/ui/skeleton';

interface AdminRBACGuardProps {
  children: React.ReactNode;
  requiredRole?: 'admin' | 'super_admin';
}

export function AdminRBACGuard({ 
  children, 
  requiredRole = 'admin' 
}: AdminRBACGuardProps) {
  const router = useRouter();
  const [isAuthorized, setIsAuthorized] = useState<boolean | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;

    async function checkAuth() {
      try {
        const user = await getCurrentUser();

        if (!isMounted) return;

        // Check if user has required role
        const hasRequiredRole = 
          requiredRole === 'super_admin' 
            ? user.role === 'super_admin'
            : user.role === 'admin' || user.role === 'super_admin';

        if (!hasRequiredRole) {
          setIsAuthorized(false);
          setError('Unauthorized: Admin access required');
          
          // Redirect to home after brief delay
          setTimeout(() => {
            if (isMounted) {
              router.push('/');
            }
          }, 1000);
          return;
        }

        setIsAuthorized(true);
      } catch (err) {
        if (!isMounted) return;

        setIsAuthorized(false);
        setError('Failed to verify authorization');
        
        // Redirect to login on auth error
        setTimeout(() => {
          if (isMounted) {
            router.push('/login');
          }
        }, 1000);
      }
    }

    checkAuth();

    return () => {
      isMounted = false;
    };
  }, [router, requiredRole]);

  // Loading state
  if (isAuthorized === null) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 w-full max-w-md px-4">
          <Skeleton className="h-12 w-full" />
          <Skeleton className="h-12 w-full" />
          <Skeleton className="h-12 w-full" />
        </div>
      </div>
    );
  }

  // Unauthorized
  if (!isAuthorized) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <h1 className="text-2xl font-bold text-red-600">Access Denied</h1>
          <p className="text-gray-600">{error}</p>
          <p className="text-sm text-gray-500">Redirecting to home...</p>
        </div>
      </div>
    );
  }

  // Authorized
  return <>{children}</>;
}
```

**Layout Implementation:**

```typescript
// apps/web/src/app/(admin)/layout.tsx
import { AdminRBACGuard } from '@/lib/components/admin-rbac-guard';
import { AdminHeader } from '@/components/admin/admin-header';
import { AdminNav } from '@/components/admin/admin-nav';

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <AdminRBACGuard requiredRole="admin">
      <div className="flex flex-col min-h-screen bg-gray-50">
        <AdminHeader />
        <div className="flex flex-1">
          <AdminNav />
          <main className="flex-1 overflow-auto">
            {children}
          </main>
        </div>
      </div>
    </AdminRBACGuard>
  );
}
```

**Session Refresh Strategy:**

```typescript
// apps/web/src/lib/hooks/useAuthRefresh.ts
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export function useAuthRefresh(intervalMs = 5 * 60 * 1000) {
  const router = useRouter();

  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        const user = await getCurrentUser();
        
        // If user is no longer admin, redirect
        if (user.role !== 'admin' && user.role !== 'super_admin') {
          router.push('/');
        }
      } catch (err) {
        // Session expired, redirect to login
        router.push('/login');
      }
    }, intervalMs);

    return () => clearInterval(interval);
  }, [router]);
}

// Usage in admin pages
export default function TenantsPage() {
  useAuthRefresh(); // Refresh auth every 5 minutes
  
  return (
    // Page content
  );
}
```

**Testing Requirements:**

**RBAC Tests (Playwright):**
```typescript
describe('RBAC Guard', () => {
  test('Admin user can access /admin/tenants', async ({ page }) => {
    // Login as admin
    await loginAsAdmin(page);
    
    // Navigate to admin page
    await page.goto('/admin/tenants');
    
    // Verify page loads
    await expect(page.locator('text=Tenants')).toBeVisible();
  });

  test('Non-admin user is redirected from /admin/tenants', async ({ page }) => {
    // Login as regular user
    await loginAsUser(page);
    
    // Try to navigate to admin page
    await page.goto('/admin/tenants');
    
    // Verify redirect to home
    await expect(page).toHaveURL('/');
  });

  test('Super admin can access /admin/tenants', async ({ page }) => {
    // Login as super admin
    await loginAsSuperAdmin(page);
    
    // Navigate to admin page
    await page.goto('/admin/tenants');
    
    // Verify page loads
    await expect(page.locator('text=Tenants')).toBeVisible();
  });

  test('Session expiry redirects to login', async ({ page }) => {
    // Login as admin
    await loginAsAdmin(page);
    
    // Navigate to admin page
    await page.goto('/admin/tenants');
    
    // Simulate session expiry
    await page.evaluate(() => {
      localStorage.removeItem('auth_token');
    });
    
    // Trigger auth refresh
    await page.waitForTimeout(1000);
    
    // Verify redirect to login
    await expect(page).toHaveURL('/login');
  });

  test('Loading state visible during auth check', async ({ page }) => {
    // Slow down network
    await page.route('**/*', route => {
      setTimeout(() => route.continue(), 2000);
    });
    
    // Navigate to admin page
    await page.goto('/admin/tenants');
    
    // Verify loading skeleton visible
    await expect(page.locator('[data-testid="loading-skeleton"]')).toBeVisible();
  });
});
```

**Residual Risk:** Low - After proper implementation and comprehensive testing

**Owner:** Frontend dev  
**Timeline:** Task 1 implementation

---

### 3. [FORM-001]: Form State Management with Async Server Actions

**Score: 6 (High)**  
**Category:** Technical / State Management  
**Probability:** Medium (2) - Complex async patterns with React Hook Form  
**Impact:** High (3) - Data loss, duplicate submissions, poor UX

**Description:**

AC1-3 require forms that submit to server actions (from 1.2.5). Risks include:

1. **Duplicate Submissions**: User clicks submit twice before response arrives
2. **Optimistic Updates**: Form resets before server confirms success
3. **Error State Recovery**: Form loses user input on error
4. **Loading State**: Button disabled but no visual feedback
5. **Validation Mismatch**: Client-side validation differs from server-side

**Affected Components:**
- `apps/web/src/app/(admin)/tenants/page.tsx` (create tenant form)
- `apps/web/src/app/(admin)/neighborhoods/page.tsx` (create neighborhood form)
- `apps/web/src/app/(admin)/lots/page.tsx` (create lot form)

**Evidence from AC:**
- AC1: "Form uses shadcn Form component with Zod validation from 1.2.5 schemas"
- AC6: "Loading state: Spinner on button during submission"
- AC6: "Success: Toast notification, form resets, table refreshes"

**Failure Scenarios:**

1. **Duplicate Submission:**
```typescript
// BAD: No submission guard
const handleSubmit = async (data) => {
  const result = await createTenantAction(data);
  if (result.success) {
    toast.success('Tenant created');
    form.reset();
  }
};

// User clicks submit twice quickly
// Both requests sent to server
// Two tenants created
```

2. **Form Reset Before Confirmation:**
```typescript
// BAD: Reset immediately
const handleSubmit = async (data) => {
  form.reset(); // Reset immediately
  const result = await createTenantAction(data);
  // If error, user's input is already gone
};
```

3. **Validation Mismatch:**
```typescript
// Client validates with one schema
const clientSchema = z.object({
  name: z.string().min(1).max(100)
});

// Server validates with different schema
const serverSchema = z.object({
  name: z.string().min(1).max(50) // Different max!
});

// User enters 75 chars, passes client validation
// Server rejects, user confused
```

**Mitigation:**

**Proper Form Implementation with React Hook Form + Server Actions:**

```typescript
// apps/web/src/app/(admin)/tenants/page.tsx
'use client';

import { useActionState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { createTenantAction } from '@/app/actions/admin';
import { TenantInsertSchema } from '@/lib/schemas/tenant';
import { Button } from '@/components/ui/button';
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';

export function CreateTenantForm({ onSuccess }: { onSuccess: () => void }) {
  const [state, formAction, isPending] = useActionState(
    async (prevState, formData) => {
      const result = await createTenantAction(
        Object.fromEntries(formData)
      );
      
      if (result.success) {
        toast.success('Tenant created successfully');
        form.reset();
        onSuccess();
      } else {
        toast.error(result.error || 'Failed to create tenant');
      }
      
      return result;
    },
    null
  );

  const form = useForm({
    resolver: zodResolver(TenantInsertSchema),
    defaultValues: {
      name: '',
      slug: '',
    },
  });

  return (
    <form action={formAction} className="space-y-4">
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Tenant Name</FormLabel>
            <FormControl>
              <Input 
                placeholder="e.g., Ecovilla Community" 
                disabled={isPending}
                {...field} 
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      <FormField
        control={form.control}
        name="slug"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Slug (optional)</FormLabel>
            <FormControl>
              <Input 
                placeholder="auto-generated from name" 
                disabled={isPending}
                {...field} 
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      <Button 
        type="submit" 
        disabled={isPending}
        className="w-full"
      >
        {isPending ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Creating...
          </>
        ) : (
          'Create Tenant'
        )}
      </Button>
    </form>
  );
}
```

**Prevent Duplicate Submissions:**

```typescript
// apps/web/src/lib/hooks/useFormSubmit.ts
import { useCallback, useRef } from 'react';

export function useFormSubmit() {
  const isSubmittingRef = useRef(false);

  const handleSubmit = useCallback(async (callback: () => Promise<any>) => {
    // Prevent duplicate submissions
    if (isSubmittingRef.current) {
      return;
    }

    isSubmittingRef.current = true;
    try {
      return await callback();
    } finally {
      isSubmittingRef.current = false;
    }
  }, []);

  return { handleSubmit };
}

// Usage
const { handleSubmit } = useFormSubmit();

const onSubmit = async (data) => {
  await handleSubmit(async () => {
    const result = await createTenantAction(data);
    // Handle result
  });
};
```

**Validation Consistency:**

```typescript
// packages/shared/lib/schemas/tenant.ts
// Single source of truth for validation
export const TenantInsertSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be 100 characters or less'),
  slug: z.string()
    .optional()
    .refine(
      (val) => !val || /^[a-z0-9-]+$/.test(val),
      'Slug must contain only lowercase letters, numbers, and hyphens'
    ),
});

// Use same schema on client and server
// Client: useForm({ resolver: zodResolver(TenantInsertSchema) })
// Server: TenantInsertSchema.parse(input)
```

**Testing Requirements:**

**Form Tests (Playwright):**
```typescript
describe('Create Tenant Form', () => {
  test('Form submission creates tenant and shows success toast', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Fill form
    await page.fill('input[name="name"]', 'New Community');
    
    // Submit
    await page.click('button:has-text("Create Tenant")');
    
    // Verify loading state
    await expect(page.locator('button:has-text("Creating...")')).toBeVisible();
    
    // Wait for success
    await expect(page.locator('text=Tenant created successfully')).toBeVisible();
    
    // Verify form reset
    await expect(page.locator('input[name="name"]')).toHaveValue('');
    
    // Verify table updated
    await expect(page.locator('text=New Community')).toBeVisible();
  });

  test('Duplicate submission is prevented', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Fill form
    await page.fill('input[name="name"]', 'New Community');
    
    // Click submit twice rapidly
    const submitButton = page.locator('button:has-text("Create Tenant")');
    await submitButton.click();
    await submitButton.click();
    
    // Wait for completion
    await page.waitForTimeout(2000);
    
    // Verify only one tenant created (check table)
    const rows = await page.locator('table tbody tr').count();
    expect(rows).toBe(1);
  });

  test('Form validation shows errors', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Submit empty form
    await page.click('button:has-text("Create Tenant")');
    
    // Verify validation error
    await expect(page.locator('text=Name is required')).toBeVisible();
  });

  test('Server error preserves form input', async ({ page }) => {
    // Mock server error
    await page.route('**/actions/admin', route => 
      route.abort('failed')
    );
    
    await page.goto('/admin/tenants');
    
    // Fill form
    await page.fill('input[name="name"]', 'New Community');
    
    // Submit
    await page.click('button:has-text("Create Tenant")');
    
    // Verify error toast
    await expect(page.locator('text=Failed to create tenant')).toBeVisible();
    
    // Verify form input preserved
    await expect(page.locator('input[name="name"]')).toHaveValue('New Community');
  });
});
```

**Residual Risk:** Low - After proper implementation and form testing

**Owner:** Frontend dev  
**Timeline:** Tasks 2-4 implementation

---

## Medium Priority Risks

### 4. [MOBILE-001]: Mobile-First Responsive Design Compliance

**Score: 4 (Medium)**  
**Category:** Design / Responsive  
**Probability:** Medium (2) - Complex layouts with multiple breakpoints  
**Impact:** Medium (2) - Poor mobile UX, accessibility issues

**Description:**

AC5 requires mobile-first design with specific breakpoints (sm: 640px, md: 768px, lg: 1024px). Risks:

1. **DataTable on Mobile**: Horizontal scrolling may be confusing
2. **Form Layout**: Side-by-side on desktop may not stack properly on mobile
3. **Touch Targets**: Interactive elements may be < 44x44px on mobile
4. **Spacing**: 8px grid may not scale properly across viewports
5. **Typography**: Font sizes may be too small on mobile

**Affected Components:**
- All admin pages (tenants, neighborhoods, lots)
- DataTable wrapper component
- Form section component

**Evidence from AC:**
- AC5: "Mobile-first (Tailwind responsive utilities: sm:, md:, lg: breakpoints)"
- AC5: "Touch targets minimum 44x44px"
- AC5: "Forms stack vertically on mobile, side-by-side on desktop"
- AC5: "DataTable is scrollable on mobile"

**Mitigation:**

**Mobile-First Tailwind Patterns:**

```typescript
// apps/web/src/app/(admin)/tenants/page.tsx
export default function TenantsPage() {
  return (
    <div className="space-y-6 p-4 sm:p-6 md:p-8">
      {/* Header */}
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <h1 className="text-2xl font-bold">Tenants</h1>
        <Button className="w-full sm:w-auto">Create Tenant</Button>
      </div>

      {/* Create Form - Stack on mobile, side-by-side on desktop */}
      <Card className="p-4 sm:p-6">
        <form className="space-y-4">
          <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <FormField name="name" label="Name" />
            <FormField name="slug" label="Slug" />
          </div>
          <Button type="submit" className="w-full">
            Create Tenant
          </Button>
        </form>
      </Card>

      {/* DataTable - Scrollable on mobile */}
      <Card className="overflow-hidden">
        <div className="overflow-x-auto">
          <DataTable columns={columns} data={tenants} />
        </div>
      </Card>
    </div>
  );
}
```

**Touch Target Compliance:**

```typescript
// Ensure all buttons/inputs are at least 44x44px
<Button className="h-11 min-h-[44px] px-4">
  Create Tenant
</Button>

<Input className="h-11 min-h-[44px]" placeholder="Name" />

<Select>
  <SelectTrigger className="h-11 min-h-[44px]">
    <SelectValue />
  </SelectTrigger>
</Select>
```

**Testing Requirements:**

**Responsive Design Tests (Playwright):**
```typescript
describe('Mobile-First Responsive Design', () => {
  const viewports = [
    { name: 'Mobile (iPhone 12)', width: 390, height: 844 },
    { name: 'Tablet (iPad)', width: 768, height: 1024 },
    { name: 'Desktop', width: 1280, height: 800 },
  ];

  viewports.forEach(({ name, width, height }) => {
    test(`Tenants page layout on ${name}`, async ({ page }) => {
      await page.setViewportSize({ width, height });
      await page.goto('/admin/tenants');

      // Verify page loads without horizontal scroll
      const bodyWidth = await page.evaluate(() => document.body.scrollWidth);
      const viewportWidth = await page.evaluate(() => window.innerWidth);
      expect(bodyWidth).toBeLessThanOrEqual(viewportWidth);

      // Verify touch targets are 44px minimum
      const buttons = await page.locator('button').all();
      for (const button of buttons) {
        const box = await button.boundingBox();
        expect(box?.height).toBeGreaterThanOrEqual(44);
        expect(box?.width).toBeGreaterThanOrEqual(44);
      }
    });
  });

  test('DataTable scrolls horizontally on mobile', async ({ page }) => {
    await page.setViewportSize({ width: 390, height: 844 });
    await page.goto('/admin/tenants');

    // Verify table is scrollable
    const tableContainer = page.locator('.overflow-x-auto');
    const isScrollable = await tableContainer.evaluate(
      el => el.scrollWidth > el.clientWidth
    );
    expect(isScrollable).toBe(true);
  });

  test('Forms stack vertically on mobile, horizontally on desktop', async ({ page }) => {
    // Mobile
    await page.setViewportSize({ width: 390, height: 844 });
    await page.goto('/admin/tenants');

    let formGrid = page.locator('form .grid');
    let gridCols = await formGrid.evaluate(
      el => window.getComputedStyle(el).gridTemplateColumns
    );
    expect(gridCols).toContain('1fr'); // Single column

    // Desktop
    await page.setViewportSize({ width: 1280, height: 800 });
    gridCols = await formGrid.evaluate(
      el => window.getComputedStyle(el).gridTemplateColumns
    );
    expect(gridCols).toContain('1fr 1fr'); // Two columns
  });
});
```

**Residual Risk:** Low - After responsive design implementation and testing

**Owner:** Frontend dev  
**Timeline:** All tasks

---

### 5. [ACC-001]: Accessibility & WCAG AA Compliance

**Score: 4 (Medium)**  
**Category:** Accessibility  
**Probability:** Medium (2) - Complex interactive components  
**Impact:** Medium (2) - Excludes users with disabilities, legal risk

**Description:**

AC7 requires WCAG AA compliance: "4.5:1 contrast, semantic HTML, keyboard navigation."

**Risks:**
1. **Color Contrast**: Design tokens may not meet 4.5:1 ratio
2. **Keyboard Navigation**: Cascading selects may not be keyboard accessible
3. **Focus Management**: Modal dialogs may not trap focus properly
4. **ARIA Labels**: Missing or incorrect ARIA labels on custom components
5. **Screen Reader Support**: DataTable may not announce column headers

**Affected Components:**
- All form inputs and buttons
- Cascading select component
- DataTable component
- Delete confirmation dialogs

**Evidence from AC:**
- AC7: "WCAG AA: 4.5:1 contrast, semantic HTML, keyboard navigation"

**Mitigation:**

**Accessibility Checklist:**

```typescript
// apps/web/src/components/admin/accessible-form-field.tsx
export function AccessibleFormField({
  label,
  error,
  required,
  children,
}: Props) {
  const id = useId();

  return (
    <div className="space-y-2">
      <label 
        htmlFor={id}
        className="block text-sm font-medium text-gray-900"
      >
        {label}
        {required && <span className="text-red-600 ml-1">*</span>}
      </label>
      
      {/* Clone child and add id */}
      {React.cloneElement(children, { id })}
      
      {error && (
        <p 
          id={`${id}-error`}
          className="text-sm text-red-600"
          role="alert"
        >
          {error}
        </p>
      )}
    </div>
  );
}
```

**Keyboard Navigation for Cascading Select:**

```typescript
// apps/web/src/components/admin/cascading-select.tsx
export function CascadingSelect() {
  const [tenantOpen, setTenantOpen] = useState(false);
  const [neighborhoodOpen, setNeighborhoodOpen] = useState(false);

  const handleTenantKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      setTenantOpen(!tenantOpen);
    }
    if (e.key === 'Escape') {
      setTenantOpen(false);
    }
  };

  return (
    <div className="space-y-4">
      <Select 
        open={tenantOpen}
        onOpenChange={setTenantOpen}
      >
        <SelectTrigger 
          onKeyDown={handleTenantKeyDown}
          aria-label="Select a tenant"
          aria-expanded={tenantOpen}
        >
          <SelectValue placeholder="Select a tenant" />
        </SelectTrigger>
        <SelectContent>
          {/* Options */}
        </SelectContent>
      </Select>

      <Select 
        disabled={!selectedTenant}
        open={neighborhoodOpen}
        onOpenChange={setNeighborhoodOpen}
      >
        <SelectTrigger 
          onKeyDown={handleTenantKeyDown}
          aria-label="Select a neighborhood"
          aria-expanded={neighborhoodOpen}
          aria-disabled={!selectedTenant}
        >
          <SelectValue placeholder="Select a neighborhood" />
        </SelectTrigger>
        <SelectContent>
          {/* Options */}
        </SelectContent>
      </Select>
    </div>
  );
}
```

**Testing Requirements:**

**Accessibility Tests (Playwright + axe):**
```typescript
import { injectAxe, checkA11y } from 'axe-playwright';

describe('Accessibility', () => {
  test('Tenants page meets WCAG AA standards', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Inject axe
    await injectAxe(page);
    
    // Check accessibility
    await checkA11y(page, null, {
      detailedReport: true,
      detailedReportOptions: {
        html: true,
      },
    });
  });

  test('Cascading select is keyboard navigable', async ({ page }) => {
    await page.goto('/admin/lots');
    
    // Tab to tenant select
    await page.keyboard.press('Tab');
    
    // Open with Enter
    await page.keyboard.press('Enter');
    
    // Verify dropdown opens
    await expect(page.locator('[role="option"]').first()).toBeVisible();
    
    // Navigate with arrow keys
    await page.keyboard.press('ArrowDown');
    
    // Select with Enter
    await page.keyboard.press('Enter');
    
    // Verify selection
    await expect(page.locator('[role="combobox"]').first()).toHaveAttribute(
      'aria-expanded',
      'false'
    );
  });

  test('Delete dialog traps focus', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Open delete dialog
    await page.click('button:has-text("Delete")');
    
    // Verify dialog is visible
    await expect(page.locator('[role="dialog"]')).toBeVisible();
    
    // Tab through dialog
    const focusedElements = [];
    for (let i = 0; i < 10; i++) {
      const focused = await page.evaluate(() => document.activeElement?.tagName);
      focusedElements.push(focused);
      await page.keyboard.press('Tab');
    }
    
    // Verify focus stays within dialog
    const dialogElements = await page.locator('[role="dialog"] *').count();
    expect(focusedElements.filter(el => el).length).toBeLessThanOrEqual(dialogElements);
  });

  test('Color contrast meets 4.5:1 ratio', async ({ page }) => {
    await page.goto('/admin/tenants');
    
    // Check all text elements
    const elements = await page.locator('*').all();
    
    for (const element of elements) {
      const styles = await element.evaluate(el => {
        const computed = window.getComputedStyle(el);
        return {
          color: computed.color,
          backgroundColor: computed.backgroundColor,
        };
      });
      
      // Calculate contrast ratio
      // (Simplified - use actual contrast calculation)
      // Verify >= 4.5:1
    }
  });
});
```

**Residual Risk:** Low - After accessibility implementation and testing

**Owner:** Frontend dev  
**Timeline:** All tasks

---

### 6. [DESIGN-001]: Design System Token Consistency

**Score: 4 (Medium)**  
**Category:** Design / Consistency  
**Probability:** Low (1) - Design system well-established  
**Impact:** Medium (2) - Visual inconsistency, brand dilution

**Description:**

AC7 requires design system alignment: "Forest Canopy header, Earth Neutral backgrounds, Sky Blue accents, Sunrise Orange CTAs."

**Risks:**
1. **Token Misuse**: Developer uses wrong color token
2. **Spacing Inconsistency**: 8px grid not followed
3. **Typography Mismatch**: Wrong font size or weight
4. **Border Radius**: Inconsistent radius across components

**Mitigation:**

**Design Token Validation:**

```typescript
// apps/web/src/lib/design-tokens.ts
export const designTokens = {
  colors: {
    forestCanopy: '#2D5016', // Header background
    earthNeutral: '#F5F3F0', // Page background
    skyBlue: '#4A90E2', // Accents
    sunriseOrange: '#FF6B35', // Primary CTA
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
  },
  borderRadius: {
    sm: '8px',
    md: '12px',
    lg: '16px',
  },
  typography: {
    body: { fontFamily: 'Inter', fontSize: '16px', lineHeight: '1.5' },
    heading: { fontFamily: 'Inter', fontSize: '24px', fontWeight: '600' },
  },
};

// Tailwind config uses these tokens
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        'forest-canopy': '#2D5016',
        'earth-neutral': '#F5F3F0',
        'sky-blue': '#4A90E2',
        'sunrise-orange': '#FF6B35',
      },
      spacing: {
        xs: '4px',
        sm: '8px',
        md: '16px',
        lg: '24px',
        xl: '32px',
      },
      borderRadius: {
        sm: '8px',
        md: '12px',
        lg: '16px',
      },
    },
  },
};
```

**Testing Requirements:**

**Design Token Tests:**
```typescript
test('Design tokens are used consistently', async ({ page }) => {
  await page.goto('/admin/tenants');
  
  // Check header uses Forest Canopy
  const header = page.locator('header');
  const bgColor = await header.evaluate(el => 
    window.getComputedStyle(el).backgroundColor
  );
  expect(bgColor).toBe('rgb(45, 80, 22)'); // Forest Canopy
  
  // Check buttons use Sunrise Orange
  const buttons = await page.locator('button[type="submit"]').all();
  for (const button of buttons) {
    const color = await button.evaluate(el =>
      window.getComputedStyle(el).backgroundColor
    );
    expect(color).toBe('rgb(255, 107, 53)'); // Sunrise Orange
  }
});
```

**Residual Risk:** Low

**Owner:** Frontend dev  
**Timeline:** All tasks

---

### 7. [TEST-001]: E2E Test Reliability & Coverage

**Score: 4 (Medium)**  
**Category:** Testing  
**Probability:** Medium (2) - Complex async interactions  
**Impact:** Medium (2) - Flaky tests, false negatives

**Description:**

AC8 requires E2E tests covering critical flows. Risks:

1. **Flaky Tests**: Timing issues with async operations
2. **Incomplete Coverage**: Edge cases not tested
3. **Mobile Viewport Issues**: Tests pass on desktop but fail on mobile
4. **Data Cleanup**: Test data not cleaned up between runs

**Affected Components:**
- All E2E test scenarios in AC8

**Mitigation:**

**Robust E2E Test Patterns:**

```typescript
// apps/web/e2e/admin-ui.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Admin UI - Tenant, Neighborhood, Lot Management', () => {
  test.beforeEach(async ({ page }) => {
    // Login as admin before each test
    await page.goto('/login');
    await page.fill('input[name="email"]', 'admin@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button:has-text("Sign In")');
    
    // Wait for redirect to dashboard
    await page.waitForURL('/dashboard');
  });

  test('Create Tenant → Neighborhood → Lot Flow', async ({ page }) => {
    // Navigate to tenants page
    await page.goto('/admin/tenants');
    await expect(page.locator('text=Tenants')).toBeVisible();

    // Create tenant
    const tenantName = `Test Tenant ${Date.now()}`;
    await page.fill('input[name="name"]', tenantName);
    await page.click('button:has-text("Create Tenant")');

    // Wait for success toast
    await expect(page.locator('text=Tenant created successfully')).toBeVisible();

    // Verify tenant appears in table
    await expect(page.locator(`text=${tenantName}`)).toBeVisible();

    // Navigate to neighborhoods
    await page.goto('/admin/neighborhoods');

    // Select tenant
    const tenantSelect = page.locator('[role="combobox"]').first();
    await tenantSelect.click();
    await page.locator(`text=${tenantName}`).click();

    // Wait for neighborhoods to load
    await page.waitForTimeout(500);

    // Create neighborhood
    const neighborhoodName = `Test Neighborhood ${Date.now()}`;
    await page.fill('input[name="name"]', neighborhoodName);
    await page.click('button:has-text("Create Neighborhood")');

    // Wait for success
    await expect(page.locator('text=Neighborhood created successfully')).toBeVisible();

    // Navigate to lots
    await page.goto('/admin/lots');

    // Select tenant and neighborhood
    const tenantSelectLots = page.locator('[role="combobox"]').first();
    await tenantSelectLots.click();
    await page.locator(`text=${tenantName}`).click();

    // Wait for neighborhoods to load
    await page.waitForTimeout(500);

    const neighborhoodSelectLots = page.locator('[role="combobox"]').nth(1);
    await neighborhoodSelectLots.click();
    await page.locator(`text=${neighborhoodName}`).click();

    // Create lot
    const lotNumber = `LOT-${Date.now()}`;
    await page.fill('input[name="lot_number"]', lotNumber);
    await page.click('button:has-text("Create Lot")');

    // Wait for success
    await expect(page.locator('text=Lot created successfully')).toBeVisible();

    // Verify lot appears in table
    await expect(page.locator(`text=${lotNumber}`)).toBeVisible();
  });

  test('RBAC Denial - Non-admin redirect', async ({ page, context }) => {
    // Create new context with non-admin user
    const newContext = await context.browser()?.newContext();
    const newPage = newContext!.newPage();

    // Login as non-admin
    await newPage.goto('/login');
    await newPage.fill('input[name="email"]', 'user@test.com');
    await newPage.fill('input[name="password"]', 'password123');
    await newPage.click('button:has-text("Sign In")');

    // Try to access admin page
    await newPage.goto('/admin/tenants');

    // Verify redirect to home
    await expect(newPage).toHaveURL('/');

    await newContext?.close();
  });

  test('Form Validation - Empty field error', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Submit empty form
    await page.click('button:has-text("Create Tenant")');

    // Verify validation error
    await expect(page.locator('text=Name is required')).toBeVisible();

    // Verify form not submitted
    const toasts = await page.locator('[role="status"]').count();
    expect(toasts).toBe(0);
  });

  test('Mobile Viewport - iPhone 12', async ({ page }) => {
    await page.setViewportSize({ width: 390, height: 844 });

    // Repeat create flow on mobile
    await page.goto('/admin/tenants');

    const tenantName = `Mobile Test ${Date.now()}`;
    await page.fill('input[name="name"]', tenantName);
    await page.click('button:has-text("Create Tenant")');

    // Verify success
    await expect(page.locator('text=Tenant created successfully')).toBeVisible();

    // Verify touch targets
    const buttons = await page.locator('button').all();
    for (const button of buttons) {
      const box = await button.boundingBox();
      expect(box?.height).toBeGreaterThanOrEqual(44);
    }
  });

  test('Delete Confirmation Dialog', async ({ page }) => {
    await page.goto('/admin/tenants');

    // Find first delete button
    const deleteButton = page.locator('button:has-text("Delete")').first();
    await deleteButton.click();

    // Verify dialog appears
    await expect(page.locator('[role="dialog"]')).toBeVisible();
    await expect(page.locator('text=Are you sure')).toBeVisible();

    // Click cancel
    await page.click('button:has-text("Cancel")');

    // Verify dialog closes
    await expect(page.locator('[role="dialog"]')).not.toBeVisible();
  });
});
```

**Residual Risk:** Low - After E2E test implementation

**Owner:** Frontend dev  
**Timeline:** Task 6

---

## Low Priority Risks

### 8. [DOC-001]: Missing Admin UI Documentation

**Score: 3 (Low)**  
**Category:** Documentation  
**Probability:** Low (1) - Clear requirements exist  
**Impact:** Medium (2) - Future maintenance complexity

**Description:**

AC7 requires documentation: "Create `docs/design_specification/admin-ui-patterns.md`"

**Mitigation:**

Create comprehensive documentation covering:
- Admin UI philosophy
- Component usage patterns
- Accessibility guidelines
- Mobile considerations
- Code examples

**Owner:** Frontend dev  
**Timeline:** Task 7

---

### 9. [PERF-001]: No Performance Monitoring

**Score: 2 (Low)**  
**Category:** Performance  
**Probability:** Low (1) - Admin UI not user-facing  
**Impact:** Low (2) - Internal tool performance

**Description:**

No performance monitoring for admin pages. Risks:

1. **Slow Cascading Selects**: Neighborhood fetch takes > 2 seconds
2. **DataTable Lag**: Large datasets cause rendering lag
3. **Form Submission Delay**: Server action takes > 5 seconds

**Mitigation:**

Add performance monitoring:
```typescript
// apps/web/src/lib/monitoring/performance.ts
export function measureAction(name: string, fn: () => Promise<any>) {
  const start = performance.now();
  return fn().finally(() => {
    const duration = performance.now() - start;
    console.log(`[PERF] ${name}: ${duration.toFixed(2)}ms`);
    
    // Alert if slow
    if (duration > 2000) {
      console.warn(`[PERF] ${name} took ${duration.toFixed(2)}ms (slow)`);
    }
  });
}
```

**Owner:** Frontend dev  
**Timeline:** Optional, post-implementation

---

## Risk Distribution Summary

| Category | Critical | High | Medium | Low | Total |
|----------|----------|------|--------|-----|-------|
| UX/Mobile | 0 | 1 | 1 | 0 | 2 |
| Security | 0 | 1 | 0 | 0 | 1 |
| Technical | 0 | 1 | 1 | 0 | 2 |
| Design | 0 | 0 | 1 | 0 | 1 |
| Testing | 0 | 0 | 1 | 0 | 1 |
| Documentation | 0 | 0 | 0 | 1 | 1 |
| Performance | 0 | 0 | 0 | 1 | 1 |

---

## Recommendations

**Before Implementation:**
1. ✅ Review and approve risk assessment
2. ✅ Confirm 1.2.5 backend is production-ready
3. ✅ Establish E2E test infrastructure (Playwright)
4. ✅ Set up design token validation in Tailwind config

**During Implementation:**
1. Implement RBAC guard first (Task 1) - blocks all other work
2. Build cascading select component with proper loading states (Task 5)
3. Implement form state management patterns early (Tasks 2-4)
4. Test mobile responsiveness continuously (all tasks)
5. Run accessibility checks regularly (all tasks)

**After Implementation:**
1. Run full E2E test suite (Task 6)
2. Conduct accessibility audit (axe, manual testing)
3. Performance test on slow networks
4. Create admin UI documentation (Task 7)

---

## Sign-Off

**Risk Assessment Status:** ✅ READY FOR IMPLEMENTATION

**Blockers:** None - 1.2.5 backend is complete

**Next Steps:** Proceed with Task 1 (Admin Layout & RBAC Guard)

**Review Date:** October 27, 2025  
**Reviewer:** Quinn (Test Architect & QA)
