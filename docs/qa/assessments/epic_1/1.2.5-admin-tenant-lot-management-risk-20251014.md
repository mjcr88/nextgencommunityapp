# Risk Profile: Story 1.2.5 - Admin Tenant & Lot Management (Technical Story)

**Date:** October 14, 2025  
**Reviewer:** Quinn (Test Architect)  
**Story Status:** In Progress (Package 1 Complete)

---

## Executive Summary

- **Total Risks Identified:** 10
- **Critical Risks (Score 9):** 1
- **High Risks (Score 6):** 2
- **Medium Risks (Score 4):** 3
- **Low Risks (Score 2-3):** 4
- **Overall Risk Score:** 52/100

**Key Concerns:**
1. RLS policy misconfiguration could allow cross-tenant data leakage (CRITICAL)
2. Incomplete repository implementation leaves backend functionality incomplete
3. Missing integration tests for hierarchy validation

---

## Critical Risks Requiring Immediate Attention

### 1. [SEC-001]: RLS Policy Misconfiguration Risk

**Score: 9 (Critical)**  
**Category:** Security  
**Probability:** High (3) - Complex multi-level FK relationships increase policy error likelihood  
**Impact:** High (3) - Cross-tenant data breach, regulatory violation, complete security failure

**Detailed Analysis:**

The hierarchical tenant → neighborhood → lot structure with RLS policies at each level creates multiple potential failure points:
- Policy on `neighborhoods` must filter by tenant_id
- Policy on `lots` must traverse neighborhood_id → tenant_id
- Super admin bypass logic must be explicit
- Tenant admin scope must be correctly bounded

**Evidence from Codebase:**
- Migration 002 exists with FK relationships established
- RLS policies created but remaining tasks show repository/action layers incomplete
- Previous Story 1.2 notes indicate successful tenant isolation tests, but added complexity in 1.2.5 increases risk

**Attack Scenarios:**
1. Malicious tenant admin queries lots from different tenant via manipulated neighborhood_id
2. RLS policy gap allows direct lot queries bypassing neighborhood filter
3. User role escalation through improper FK validation in repositories

**Mitigation:**

**Immediate Actions Required:**
1. **Explicit RLS Testing** (Before any production data):
   ```sql
   -- Test cross-tenant isolation
   SET ROLE authenticated;
   SET request.jwt.claims.tenant_id TO 'tenant-A-uuid';
   SELECT * FROM neighborhoods WHERE tenant_id = 'tenant-B-uuid'; 
   -- MUST return empty set
   
   SELECT * FROM lots 
   WHERE neighborhood_id IN (
     SELECT id FROM neighborhoods WHERE tenant_id = 'tenant-B-uuid'
   );
   -- MUST return empty set
   ```

2. **Repository Layer Validation** (In Progress):
   - MUST validate tenant_id in every create/read operation
   - MUST use Supabase client with RLS enabled (not service role for user operations)
   - Example from repo task: `Supabase.from('neighborhoods').insert({...}).select()` must enforce RLS

3. **Integration Test Requirements**:
   ```typescript
   // Required test in admin.integration.test.ts
   describe('RLS Isolation Tests', () => {
     test('Tenant A admin cannot access Tenant B neighborhoods', async () => {
       // Mock Tenant A admin session
       // Attempt to query Tenant B neighborhood
       // Assert: empty result or 403 error
     });
     
     test('Lot queries respect tenant boundaries through neighborhood FK', async () => {
       // Create lot in Tenant A neighborhood
       // Switch to Tenant B session
       // Attempt to query lot directly by ID
       // Assert: empty result
     });
   });
   ```

4. **Action Layer Guards** (Not Yet Implemented):
   ```typescript
   // Required in apps/web/app/actions/admin.ts
   export async function createNeighborhoodAction(input: CreateNeighborhoodInput) {
     const user = await getCurrentUser(); // From Story 1.2
     
     // CRITICAL: Verify user has access to tenant
     if (user.role !== 'super_admin' && user.tenant_id !== input.tenant_id) {
       throw new AppError('Unauthorized tenant access', 'FORBIDDEN');
     }
     
     // Additional validation: tenant exists
     const tenant = await getTenantById(input.tenant_id);
     if (!tenant) {
       throw new AppError('Invalid tenant', 'NOT_FOUND');
     }
     
     return neighborhoodRepo.create(input);
   }
   ```

**Testing Requirements:**
- **P0 Security Tests** (Integration):
  - Cross-tenant neighborhood access denial
  - Cross-tenant lot access denial  
  - Tenant admin scope validation
  - Super admin bypass verification
- **P0 Manual Penetration Tests** (Using MCP like Story 1.2):
  - Attempt direct SQL queries with different tenant_id in JWT
  - Verify no data leakage in error messages
  - Test with expired/malformed JWTs

**Residual Risk:** Low - After implementation of all mitigations and successful penetration testing

**Owner:** dev (backend implementation)  
**Timeline:** MUST be completed before Story 1.2.6 (UI) and Story 1.3 (user creation)

---

## High Priority Risks

### 2. [DATA-001]: Incomplete Hierarchy Validation

**Score: 6 (High)**  
**Category:** Data Integrity  
**Probability:** Medium (2) - FK constraints exist but application logic incomplete  
**Impact:** High (3) - Data corruption, orphaned records, cascade delete failures

**Description:**

The tenant → neighborhood → lot → user hierarchy requires strict validation at each level:

**Current State Analysis:**
- ✅ Database FK constraints defined in migration 002
- ✅ Zod schemas created for neighborhood and lot
- ❌ Repository functions not implemented (critical gap)
- ❌ Server actions not created
- ❌ Integration tests not written

**Failure Scenarios:**
1. **Orphaned Lots**: Neighborhood deleted but lots remain (FK cascade not tested)
2. **Invalid Assignments**: Lot assigned to user from different tenant
3. **Status Conflicts**: Lot marked "assigned" but no user reference, or vice versa
4. **Duplicate Lot Numbers**: Same lot_number created in same neighborhood (unique constraint per AC2 not validated in code)

**Affected Components:**
- `packages/database/src/lib/repositories/neighborhood.ts` (not created)
- `packages/database/src/lib/repositories/lot.ts` (not created)
- `packages/shared/lib/schemas/user.ts` (lot_id added but validation incomplete)
- `apps/web/app/actions/admin.ts` (not created)

**Mitigation:**

**Repository Layer Requirements** (From Dev Notes):
```typescript
// Required in neighborhood.ts
export async function createNeighborhood(input: InsertNeighborhoodInput) {
  // 1. Validate tenant exists
  const tenant = await getTenant(input.tenant_id);
  if (!tenant) {
    throw new AppError('Invalid tenant_id', 'VALIDATION_ERROR');
  }
  
  // 2. Parse with Zod
  const validated = NeighborhoodSchema.parse(input);
  
  // 3. Insert with RLS enforcement
  const { data, error } = await supabase
    .from('neighborhoods')
    .insert(validated)
    .select()
    .single();
    
  if (error) {
    throw new AppError('Failed to create neighborhood', 'DATABASE_ERROR');
  }
  
  return data;
}

// Required in lot.ts
export async function createLot(input: InsertLotInput) {
  // 1. Validate neighborhood exists and belongs to correct tenant
  const neighborhood = await getNeighborhoodById(input.neighborhood_id);
  if (!neighborhood) {
    throw new AppError('Invalid neighborhood_id', 'VALIDATION_ERROR');
  }
  
  // 2. Check lot_number uniqueness per neighborhood (AC2)
  const existing = await supabase
    .from('lots')
    .select('id')
    .eq('neighborhood_id', input.neighborhood_id)
    .eq('lot_number', input.lot_number)
    .single();
    
  if (existing.data) {
    throw new AppError(
      `Lot ${input.lot_number} already exists in this neighborhood`,
      'DUPLICATE_ERROR'
    );
  }
  
  // 3. Parse and insert
  const validated = LotSchema.parse(input);
  // ... insert logic
}
```

**Integration Test Requirements:**
```typescript
describe('Hierarchy Validation', () => {
  test('Cannot create neighborhood with invalid tenant_id', async () => {
    await expect(
      createNeighborhood({ tenant_id: 'invalid-uuid', name: 'Test' })
    ).rejects.toThrow('Invalid tenant_id');
  });
  
  test('Cannot create lot with invalid neighborhood_id', async () => {
    await expect(
      createLot({ neighborhood_id: 'invalid-uuid', lot_number: '101' })
    ).rejects.toThrow('Invalid neighborhood_id');
  });
  
  test('Duplicate lot_number in same neighborhood fails', async () => {
    const lot1 = await createLot({ neighborhood_id: 'n1', lot_number: '101' });
    await expect(
      createLot({ neighborhood_id: 'n1', lot_number: '101' })
    ).rejects.toThrow('already exists');
  });
  
  test('Same lot_number in different neighborhoods succeeds', async () => {
    const lot1 = await createLot({ neighborhood_id: 'n1', lot_number: '101' });
    const lot2 = await createLot({ neighborhood_id: 'n2', lot_number: '101' });
    expect(lot1.lot_number).toBe(lot2.lot_number);
  });
  
  test('Deleting neighborhood cascades to lots', async () => {
    // Create neighborhood with lots
    // Delete neighborhood
    // Verify lots are deleted (or soft-deleted based on requirements)
  });
});
```

**Residual Risk:** Low - With complete repository implementation and integration tests

**Owner:** dev  
**Timeline:** Current sprint (blocking Story 1.2.6 and 1.3)

---

### 3. [PERF-001]: N+1 Query Risk in Hierarchical Fetches

**Score: 6 (High)**  
**Category:** Performance  
**Probability:** Medium (2) - Common pattern in ORM-style queries  
**Impact:** High (3) - Severe performance degradation with > 100 neighborhoods

**Description:**

Fetching tenants with neighborhoods and their lots could result in N+1 queries:

**Anti-Pattern Example:**
```typescript
// BAD: N+1 queries
async function getTenantsWithNeighborhoods() {
  const tenants = await supabase.from('tenants').select('*');
  
  for (const tenant of tenants.data) {
    // N queries for neighborhoods
    tenant.neighborhoods = await supabase
      .from('neighborhoods')
      .select('*')
      .eq('tenant_id', tenant.id);
      
    for (const neighborhood of tenant.neighborhoods) {
      // N*M queries for lots
      neighborhood.lots = await supabase
        .from('lots')
        .select('*')
        .eq('neighborhood_id', neighborhood.id);
    }
  }
}
```

**Impact Analysis:**
- 1 tenant with 10 neighborhoods and 20 lots/neighborhood = 211 queries
- 200ms per query = 42+ seconds load time
- Exponential growth with scale

**Mitigation:**

**Use Supabase Relational Queries:**
```typescript
// GOOD: Single query with joins
async function getTenantsWithNeighborhoods() {
  const { data, error } = await supabase
    .from('tenants')
    .select(`
      *,
      neighborhoods (
        *,
        lots (*)
      )
    `)
    .order('created_at', { ascending: false });
    
  return data; // Nested structure returned in single query
}

// Alternative: Separate optimized queries with Promise.all
async function getNeighborhoodWithLots(neighborhoodId: string) {
  const [neighborhood, lots] = await Promise.all([
    supabase.from('neighborhoods').select('*').eq('id', neighborhoodId).single(),
    supabase.from('lots').select('*').eq('neighborhood_id', neighborhoodId)
  ]);
  
  return { ...neighborhood.data, lots: lots.data };
}
```

**Monitoring Requirements:**
- Add query timing logs in repositories
- Set performance budget: < 500ms for tenant hierarchy fetch
- Alert on queries > 1 second

**Testing Requirements:**
- Load test with realistic data volume (1 tenant, 20 neighborhoods, 400 lots)
- Measure query counts and timing
- Verify single query for nested fetches

**Residual Risk:** Low - After query optimization and load testing

**Owner:** dev  
**Timeline:** During repository implementation

---

## Medium Priority Risks

### 4. [TECH-001]: Inconsistent Error Handling Across Layers

**Score: 4 (Medium)**  
**Category:** Technical  
**Probability:** Medium (2) - Multiple layers (repo, action, UI) with different error patterns  
**Impact:** Medium (2) - Poor UX, debugging difficulties, inconsistent responses

**Description:**

Error handling must be consistent across:
1. Database layer (Supabase errors)
2. Repository layer (AppError instances)
3. Action layer (server action returns)
4. UI layer (1.2.6) (toast notifications)

**Current State:**
- Story 1.2 established AppError pattern
- No error handling implemented yet in 1.2.5 code

**Mitigation:**

**Establish Error Hierarchy:**
```typescript
// packages/shared/lib/errors.ts (from Story 1.2)
export class AppError extends Error {
  constructor(
    message: string,
    public code: 'VALIDATION_ERROR' | 'DATABASE_ERROR' | 'FORBIDDEN' | 'NOT_FOUND' | 'DUPLICATE_ERROR',
    public meta?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// Repository layer usage
try {
  const result = await supabase.from('lots').insert(data);
  if (result.error) {
    throw new AppError(
      'Failed to create lot',
      'DATABASE_ERROR',
      { supabaseError: result.error }
    );
  }
} catch (error) {
  if (error instanceof AppError) throw error;
  throw new AppError('Unexpected error', 'DATABASE_ERROR', { original: error });
}

// Action layer usage
export async function createLotAction(input: CreateLotInput) {
  try {
    const validated = LotSchema.parse(input);
    return await lotRepo.createLot(validated);
  } catch (error) {
    if (error instanceof ZodError) {
      return {
        success: false,
        error: 'Invalid input',
        issues: error.issues
      };
    }
    if (error instanceof AppError) {
      return {
        success: false,
        error: error.message,
        code: error.code
      };
    }
    return {
      success: false,
      error: 'An unexpected error occurred'
    };
  }
}
```

**Testing Requirements:**
- Unit tests for each error type
- Integration tests for error propagation
- Verify error messages are user-friendly (no internal details leaked)

**Residual Risk:** Low

**Owner:** dev  
**Timeline:** During repository/action implementation

---

### 5. [OPS-001]: Missing Seed Data Validation

**Score: 4 (Medium)**  
**Category:** Operational  
**Probability:** Medium (2) - Seed data exists but validation incomplete  
**Impact:** Medium (2) - Development/testing delays, incorrect initial state

**Description:**

AC6 requires seed data:
- Initial "Ecovilla" tenant
- Neighborhoods: "Almendro", "Bamboo", etc.
- Sample lots per neighborhood (e.g., "lot_101" available)

**Current State:**
- Story 1.2 seed created tenant and super admin
- No neighborhoods/lots seed implemented yet

**Risks:**
- Seed script fails silently
- Incorrect FK relationships in seed
- Missing validation of seeded data
- Seed data conflicts with test data

**Mitigation:**

**Seed Script Requirements:**
```typescript
// packages/database/scripts/seed-neighborhoods-lots.ts
import { createClient } from '@supabase/supabase-js';

async function seedNeighborhoodsLots() {
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  
  // 1. Verify Ecovilla tenant exists (from Story 1.2 seed)
  const { data: tenant } = await supabase
    .from('tenants')
    .select('id')
    .eq('name', 'Ecovilla')
    .single();
    
  if (!tenant) {
    throw new Error('Ecovilla tenant not found - run Story 1.2 seed first');
  }
  
  // 2. Create neighborhoods
  const neighborhoods = [
    { tenant_id: tenant.id, name: 'Almendro', description: 'Primary residential area' },
    { tenant_id: tenant.id, name: 'Bamboo', description: 'Eco-housing section' },
    { tenant_id: tenant.id, name: 'Cedar', description: 'Community spaces' }
  ];
  
  const { data: createdNeighborhoods, error: neighError } = await supabase
    .from('neighborhoods')
    .upsert(neighborhoods, { onConflict: 'tenant_id,name' })
    .select();
    
  if (neighError) throw neighError;
  
  // 3. Create sample lots per neighborhood
  const lots = createdNeighborhoods.flatMap((neigh, idx) => 
    Array.from({ length: 10 }, (_, i) => ({
      neighborhood_id: neigh.id,
      lot_number: `${(idx + 1) * 100 + i + 1}`, // 101-110, 201-210, etc.
      status: 'available'
    }))
  );
  
  const { error: lotError } = await supabase
    .from('lots')
    .upsert(lots, { onConflict: 'neighborhood_id,lot_number' });
    
  if (lotError) throw lotError;
  
  console.log(`✅ Seeded ${createdNeighborhoods.length} neighborhoods with ${lots.length} lots`);
  
  // 4. Validate seed data
  await validateSeed(supabase, tenant.id);
}

async function validateSeed(supabase, tenantId) {
  const { count: neighCount } = await supabase
    .from('neighborhoods')
    .select('*', { count: 'exact', head: true })
    .eq('tenant_id', tenantId);
    
  const { count: lotCount } = await supabase
    .from('lots')
    .select('*', { count: 'exact', head: true })
    .in('neighborhood_id', /* neighborhood IDs */);
    
  console.log(`Validation: ${neighCount} neighborhoods, ${lotCount} lots`);
  
  if (neighCount < 3 || lotCount < 30) {
    throw new Error('Seed validation failed');
  }
}
```

**Testing Requirements:**
- Seed script runs idempotently (can run multiple times)
- Validates existing Story 1.2 seed dependencies
- Verifies all FK relationships
- Tests with empty database and with existing data

**Residual Risk:** Low

**Owner:** dev  
**Timeline:** After repository implementation, before Story 1.2.6

---

### 6. [TECH-002]: API Contract Instability for Story 1.2.6

**Score: 4 (Medium)**  
**Category:** Technical  
**Probability:** Medium (2) - Backend-first approach without UI contract definition  
**Impact:** Medium (2) - Rework required when UI integration happens

**Description:**

Story 1.2.6 (UI) depends on server actions from this story. Without defined contracts, there's risk of:
- Action signatures changing during UI implementation
- Missing required fields in responses
- Inconsistent error response formats
- Breaking changes requiring backend rework

**Mitigation:**

**Define Action Contracts Now:**
```typescript
// apps/web/app/actions/admin.ts (contract definition)

// ============ TYPE DEFINITIONS ============

export type ActionResult<T> = 
  | { success: true; data: T }
  | { success: false; error: string; code?: string; issues?: any[] };

export interface CreateTenantInput {
  name: string;
  slug: string;
  domain?: string;
  settings?: Record<string, any>;
}

export interface CreateNeighborhoodInput {
  tenant_id: string;
  name: string;
  description?: string;
  settings?: Record<string, any>;
}

export interface CreateLotInput {
  neighborhood_id: string;
  lot_number: string;
  status?: 'available' | 'assigned';
  geo_bounds?: Record<string, any>;
}

export interface TenantWithNeighborhoods {
  id: string;
  name: string;
  slug: string;
  neighborhoods: NeighborhoodWithLots[];
}

export interface NeighborhoodWithLots {
  id: string;
  name: string;
  tenant_id: string;
  lots: Lot[];
}

export interface Lot {
  id: string;
  neighborhood_id: string;
  lot_number: string;
  status: 'available' | 'assigned';
  geo_bounds?: Record<string, any>;
}

// ============ ACTION SIGNATURES ============

export async function listTenantsAction(): Promise<ActionResult<TenantWithNeighborhoods[]>>;

export async function createTenantAction(input: CreateTenantInput): Promise<ActionResult<Tenant>>;

export async function listNeighborhoodsByTenantAction(tenantId: string): Promise<ActionResult<Neighborhood[]>>;

export async function createNeighborhoodAction(input: CreateNeighborhoodInput): Promise<ActionResult<Neighborhood>>;

export async function listAvailableLotsByNeighborhoodAction(neighborhoodId: string): Promise<ActionResult<Lot[]>>;

export async function createLotAction(input: CreateLotInput): Promise<ActionResult<Lot>>;
```

**Integration Test Contract Validation:**
```typescript
describe('Action Contracts', () => {
  test('createTenantAction returns expected shape', async () => {
    const result = await createTenantAction({ name: 'Test', slug: 'test' });
    
    if (result.success) {
      expect(result.data).toHaveProperty('id');
      expect(result.data).toHaveProperty('name');
      expect(result.data).toHaveProperty('slug');
    } else {
      expect(result).toHaveProperty('error');
      expect(typeof result.error).toBe('string');
    }
  });
  
  // Repeat for all actions...
});
```

**Documentation for Story 1.2.6:**
Create `docs/api-contracts/admin-actions.md` with:
- All action signatures
- Request/response examples
- Error code definitions
- Usage examples

**Residual Risk:** Low - After contract definition and documentation

**Owner:** dev (backend) + coordination with Story 1.2.6 owner  
**Timeline:** Before Story 1.2.6 starts

---

## Low Priority Risks

### 7. [DOC-001]: Incomplete Architecture Documentation

**Score: 3 (Low)**  
**Category:** Documentation  
**Probability:** Low (1) - Clear documentation standards exist  
**Impact:** High (3) - Future maintenance complexity, onboarding delays

**Description:**

AC requires updating `architecture/source-tree.md` with new paths. Current risks:
- Missing documentation of new files
- Incomplete relationship diagrams
- No migration history documentation

**Mitigation:**

**Update Required:**
```markdown
## packages/database/schema/

- 001_create_tenants_users_tables.sql - Story 1.2 foundation
- 002_add_neighborhoods_lots_tables.sql - Story 1.2.5 hierarchy

## packages/shared/lib/schemas/

- user.ts - User/tenant Zod schemas (1.2, extended in 1.2.5 with lot_id)
- neighborhood.ts - Neighborhood schemas (1.2.5)
- lot.ts - Lot schemas (1.2.5)

## packages/database/src/lib/repositories/

- user.ts - User CRUD (1.2)
- tenant.ts - Tenant CRUD (1.2.5)
- neighborhood.ts - Neighborhood CRUD with tenant scoping (1.2.5)
- lot.ts - Lot CRUD with neighborhood scoping (1.2.5)

## apps/web/app/actions/

- user.ts - Auth actions (1.2)
- admin.ts - Tenant/neighborhood/lot management actions (1.2.5)

## Hierarchy Diagram

```
Tenant (1)
  └── Neighborhoods (N)
        └── Lots (N)
              └── User (optional, 1:1)
```
```

**Residual Risk:** Low  
**Owner:** dev  
**Timeline:** End of story implementation

---

### 8. [TEST-001]: Incomplete Test Coverage Planning

**Score: 3 (Low)**  
**Category:** Testing  
**Probability:** Low (1) - Test requirements clear from AC5  
**Impact:** High (3) - Production bugs, security vulnerabilities

**Description:**

While AC5 specifies integration/unit tests, detailed test scenarios not defined. Risks:
- Edge cases missed
- Mock strategy inconsistent with Story 1.2
- RLS tests incomplete

**Mitigation:**

**Test Coverage Matrix Required:**

| Category | Test Type | Priority | Test Case | Status |
|----------|-----------|----------|-----------|--------|
| Security | Integration | P0 | Cross-tenant neighborhood isolation | Planned |
| Security | Integration | P0 | Cross-tenant lot isolation | Planned |
| Security | Integration | P0 | Super admin bypass verification | Planned |
| Security | Integration | P0 | Tenant admin scope validation | Planned |
| Data | Integration | P0 | Hierarchy creation (tenant→neigh→lot) | Planned |
| Data | Integration | P0 | Lot assignment to user | Planned |
| Data | Unit | P1 | Duplicate lot_number in same neighborhood | Planned |
| Data | Unit | P1 | Same lot_number in different neighborhoods | Planned |
| Data | Integration | P1 | Cascade delete verification | Planned |
| Validation | Unit | P1 | Invalid tenant_id in neighborhood | Planned |
| Validation | Unit | P1 | Invalid neighborhood_id in lot | Planned |
| Validation | Unit | P1 | Zod schema validation (all schemas) | Planned |

**Mock Strategy (From Story 1.2):**
```typescript
// Reuse Story 1.2 patterns
const mockSupabase = {
  from: jest.fn().mockReturnThis(),
  insert: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  eq: jest.fn().mockReturnThis(),
  single: jest.fn().mockResolvedValue({ data: mockData, error: null })
};
```

**Residual Risk:** Low - After test implementation

**Owner:** dev  
**Timeline:** During repository/action implementation

---

### 9. [PERF-002]: Lack of Database Indexing Strategy

**Score: 2 (Low)**  
**Category:** Performance  
**Probability:** Low (1) - Basic indexes likely exist from migration  
**Impact:** Medium (2) - Slow queries at scale

**Description:**

While migration 002 includes "indexes on FKs", comprehensive indexing strategy not documented. Risks:
- Missing composite indexes for common queries
- No indexes on frequently filtered fields (e.g., lot.status)

**Mitigation:**

**Review Migration 002:**
Verify these indexes exist:
```sql
-- FK indexes (should exist from migration)
CREATE INDEX idx_neighborhoods_tenant_id ON neighborhoods(tenant_id);
CREATE INDEX idx_lots_neighborhood_id ON lots(neighborhood_id);

-- Additional recommended indexes
CREATE INDEX idx_lots_status ON lots(status);
CREATE INDEX idx_lots_neighborhood_status ON lots(neighborhood_id, status);
CREATE INDEX idx_neighborhoods_tenant_name ON neighborhoods(tenant_id, name);
```

**Query Analysis Required:**
- Profile common queries (listByTenant, getAvailableByNeighborhood)
- Verify EXPLAIN ANALYZE shows index usage
- Add indexes if missing

**Residual Risk:** Low

**Owner:** dev  
**Timeline:** Before load testing

---

### 10. [OPS-002]: No Rollback Strategy for Migration 002

**Score: 2 (Low)**  
**Category:** Operational  
**Probability:** Low (1) - Migrations typically succeed  
**Impact:** Medium (2) - Downtime if migration fails

**Description:**

Migration 002 creates tables and policies. No documented rollback procedure if issues arise.

**Mitigation:**

**Create Rollback Script:**
```sql
-- 002_rollback.sql
DROP POLICY IF EXISTS "Policy name" ON neighborhoods;
DROP POLICY IF EXISTS "Policy name" ON lots;
DROP TABLE IF EXISTS lots CASCADE;
DROP TABLE IF EXISTS neighborhoods CASCADE;
```

**Deployment Process:**
1. Backup database before migration
2. Run migration in transaction (if possible with Supabase CLI)
3. Verify migration with test queries
4. Document rollback procedure in migration file

**Residual Risk:** Low

**Owner:** dev  
**Timeline:** Before production deployment

---

## Risk Distribution Analysis

### By Category

| Category | Critical | High | Medium | Low | Total |
|----------|----------|------|--------|-----|-------|
| Security | 1 | 0 | 0 | 0 | 1 |
| Data | 0 | 1 | 0 | 0 | 1 |
| Technical | 0 | 0 | 2 | 0 | 2 |
| Performance | 0 | 1 | 0 | 1 | 2 |
| Testing | 0 | 0 | 0 | 1 | 1 |
| Operational | 0 | 0 | 1 | 1 | 2 |
| Documentation | 0 | 0 | 0 | 1 | 1 |

### By Component

|